{"meta":{"title":"Amos","subtitle":"Amos","description":"记录Amos成长路上点点滴滴~","author":"John Doe","url":"http://blog.amoswxz.com"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2018-05-07T15:35:19.422Z","updated":"2018-05-07T15:35:19.404Z","comments":false,"path":"/404.html","permalink":"http://blog.amoswxz.com//404.html","excerpt":"","text":""},{"title":"关于","date":"2018-05-04T08:51:18.880Z","updated":"2018-04-24T06:02:16.655Z","comments":false,"path":"about/index.html","permalink":"http://blog.amoswxz.com/about/index.html","excerpt":"","text":"个人详细介绍 12345678910111213141516171819202122232425262728&#123; name: '王小中' age: 22, gender: '男', profession: 'java开发', experience: '3年', address: '北京朝阳', education: '专科', github: 'https://github.com/amoswxz', blog: 'http://amoswxz.com', email: 'amoswxz@gmail.com', description: '后端开发，喜爱Java，乐于全栈', skills: [ ['Java', 'Python'], ['Spring', 'SpringBoot','SpringCloud','Mybatis'], ['Mysql', 'Oracle'], ['Git', 'SVN'], ['Docker'], ['React'], ], devTools: [ ['Intellij IDEA', 'DataGrip'， 'WebStorm', 'PyCharm', 'Sublime Text'], ['Chrome DevTools'], ['Iterm'], ] &#125;"},{"title":"书单","date":"2018-05-07T15:35:19.423Z","updated":"2018-04-23T17:13:19.913Z","comments":false,"path":"books/index.html","permalink":"http://blog.amoswxz.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-04-24T14:26:15.829Z","updated":"2018-04-24T14:26:15.827Z","comments":false,"path":"categories/index.html","permalink":"http://blog.amoswxz.com/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2018-05-04T08:51:14.693Z","updated":"2018-04-23T17:13:19.907Z","comments":false,"path":"repository/index.html","permalink":"http://blog.amoswxz.com/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-04-23T16:58:58.491Z","updated":"2018-04-23T16:58:58.490Z","comments":false,"path":"links/index.html","permalink":"http://blog.amoswxz.com/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-04-24T14:23:53.937Z","updated":"2018-04-24T14:23:53.936Z","comments":false,"path":"tags/index.html","permalink":"http://blog.amoswxz.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Compare-And-Swap","slug":"CAS","date":"2018-06-04T16:00:00.000Z","updated":"2018-06-06T09:43:23.137Z","comments":true,"path":"2018/06/05/CAS/","link":"","permalink":"http://blog.amoswxz.com/2018/06/05/CAS/","excerpt":"","text":"一：CAS(Compare-And-Swap)对比交换1：CAS是通过一条CPU的原子指令，让CPU先比较两个值是否相等，然后原子的更新某个位置的值。其实现原理是通过汇编原理。 2：CAS的操作需要输入两个值，一个旧值（原来的值），一个新值（要更改的值）。根据unsafe获取值在内存中的偏移量。然后通过CAS执行比较旧值和原来的值是否相等，如果相等进行更新，否则不更新。 3：CAS操作是原子的，所以多线程下使用CAS来更新数据是ojbk的。juc下面的atomic包下面的类都是采用CAS。 二：CAS究竟是怎么保证原子1：有同学就有疑问了java中是怎么使用CAS来更新的呢？我们带着这个疑问慢慢往下看。unsafe是java提供的获得对象内存地址访问的类。unsafe内部使用CAS自旋的方式（while循环进行CAS更新，如果更新失败，则循环再次重试）。 有且仅有三个原子更新方法的compareAndSwapObject，compareAndSwapInt，compareAndSwapLong 12345public final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5); public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5); public final native boolean compareAndSwapLong(Object var1, long var2, long var4, long var6); 2：下面代码就是获取值value在内存中的偏移量 123456789101112// setup to use Unsafe.compareAndSwapInt for updates private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(\"value\")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125;//volatile 简介：内存可见性；指令重排 private volatile int value; 3：CAS缺点1：CAS采用自旋的方式更新，如果自旋长时间不成功，会给CPU带来非常大的开销。 2：ABA问题。CAS更新的时候会比较原来的值和旧值。如果原来的值是1，变为2，然后又变为1。CAS判断的时候就会认为这个值没有变化。实则不然，这个值是变化的。举个例子： 线程 1 从内存位置V中取出A。 线程 2 从位置V中取出A。 线程 2 进行了一些操作，将B写入位置V。 线程 2 将A再次写入位置V。 线程 1 进行CAS操作，发现位置V中仍然是A，操作成功。 尽管线程 1 的CAS操作成功，但不代表这个过程没有问题——对于线程 1 ，线程 2 的修改已经丢失。 3：解决ABA问题一种思路是在变量面前添加版本号。1A-2B-3A。从java1.5开始atomic包下面提供了一个AtomicStampedReference来解决这个问题。AtomicStampedReference本质是有一个int 值作为版本号，每次更改前先取到这个int值的版本号，等到修改的时候，比较当前版本号与当前线程持有的版本号是否一致，如果一致，则进行修改，并将版本号+1（当然加多少或减多少都是可以自己定义的），在zookeeper中保持数据的一致性也是用的这种方式。 ###4 ：AtomicStampedReference源码解析 123456789101112131415161718192021222324252627282930313233343536373839 /** * @param initialRef 初始化引用 * @param initialStamp 初始化stamp */ public AtomicStampedReference(V initialRef, int initialStamp) &#123; pair = Pair.of(initialRef, initialStamp); &#125;private static class Pair&lt;T&gt; &#123; final T reference; final int stamp; private Pair(T reference, int stamp) &#123; this.reference = reference; this.stamp = stamp; &#125; static &lt;T&gt; Pair&lt;T&gt; of(T reference, int stamp) &#123; return new Pair&lt;T&gt;(reference, stamp); &#125; &#125; private volatile Pair&lt;V&gt; pair; /*** 期待的引用和当前引用是否相等* 期待的Stamp和当前的stamp是否相等* 如果当前的引用和当前stamp和新的引用，新的stamp相等 说明当前更新的值已经存在啦，如果有一个不相等则进入cas更新*/ public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) &#123; Pair&lt;V&gt; current = pair; return expectedReference == current.reference &amp;&amp; expectedStamp == current.stamp &amp;&amp; ((newReference == current.reference &amp;&amp; newStamp == current.stamp) || casPair(current, Pair.of(newReference, newStamp))); &#125;","categories":[{"name":"并发包","slug":"并发包","permalink":"http://blog.amoswxz.com/categories/并发包/"}],"tags":[{"name":"对比交换","slug":"对比交换","permalink":"http://blog.amoswxz.com/tags/对比交换/"}]},{"title":"集合源码篇（HashSet）","slug":"HashSet","date":"2018-05-31T16:00:00.000Z","updated":"2018-06-04T02:58:14.771Z","comments":true,"path":"2018/06/01/HashSet/","link":"","permalink":"http://blog.amoswxz.com/2018/06/01/HashSet/","excerpt":"","text":"一：HashSet简介1：对于HashSet而言，它是基于HashMap实现的，HashSet底层使用HashMap来保存所有元素，因此HashSet 的实现比较简单，相关HashSet的操作，基本上都是直接调用底层HashMap的相关方法来完成。HashSet就不重复介绍啦。 二：HashSet类关系继承图","categories":[{"name":"集合源码","slug":"集合源码","permalink":"http://blog.amoswxz.com/categories/集合源码/"}],"tags":[{"name":"集合源码","slug":"集合源码","permalink":"http://blog.amoswxz.com/tags/集合源码/"}]},{"title":"AbstractQueuedSynchronizer","slug":"AbstractQueuedSynchronizer","date":"2018-05-29T16:00:00.000Z","updated":"2018-06-05T09:40:18.771Z","comments":true,"path":"2018/05/30/AbstractQueuedSynchronizer/","link":"","permalink":"http://blog.amoswxz.com/2018/05/30/AbstractQueuedSynchronizer/","excerpt":"","text":"一：AQS(AbstractQueuedSynchronizer)：即队列同步器1：AQS可以实现独占锁和共享锁。 1.1：独占锁exclusive是一个悲观锁。保证只有一个线程经过一个阻塞点，只有一个线程可以获得锁。 1.2：共享锁shared是一个乐观锁。可以允许多个线程阻塞点，可以多个线程同时获取到锁。 它允许一个资源可以被多个读操作，或者被一个写操作访问，但是两个操作不能同时访问。 2：AQS使用一个int类型的成员变量state来表示同步状态，当state&gt;0时表示已经获取了锁，当state = 0无锁。它提供了三个方法（getState()、setState(int newState)、compareAndSetState(int expect,int update)）来对同步状态state进行操作，可以确保对state的操作是安全的。 3：AQS是通过一个CLH队列实现的（CLH锁即Craig, Landin, and Hagersten (CLH) locks，CLH锁是一个自旋锁，能确保无饥饿性，提供先来先服务的公平性。 CLH锁也是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程只在本地变量上自旋，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋。） 二：类关系继承图 AbstractOwnableSynchronizer是一个把当前线程设置为独占线程的类。 三：源码解析 1：成员变量 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 队列的头结点,懒加载。修改Head只能通过setHead方法。 * 如果头结点存在,那么waitstatus一定不能为CANCELLED，就是说当前线程不能被取消 */ private transient volatile Node head; /** * 队列的尾节点，懒加载。只能通过enq()的add方法创建新节点 */ private transient volatile Node tail; /** * 队列同步器的状态 */ private volatile int state; /** *返回当前的state值 */ protected final int getState() &#123; return state; &#125; /** *设置新状态值 */ protected final void setState(int newState) &#123; state = newState; &#125; /** * Atomically sets synchronization state to the given updated * value if the current state value equals the expected value. * This operation has memory semantics of a &#123;@code volatile&#125; read * and write. * * @param expect the expected value 原来的值 * @param update 需要修改的新值 * @return &#123;@code true&#125; if successful. False return indicates that the actual * value was not equal to the expected value. */ protected final boolean compareAndSetState(int expect, int update) &#123; // See below for intrinsics setup to support this return unsafe.compareAndSwapInt(this, stateOffset, expect, update); &#125; 2：Node结构 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121static final class Node &#123; /** 表示节点正在共享模式下的等待标记 */ static final Node SHARED = new Node(); /** 表示节点正在独占模式下的等待标记 */ static final Node EXCLUSIVE = null; /** waitStatus 的值，表示线程已经取消 */ static final int CANCELLED = 1; /** waitStatus 的值，表示后继线程需要取消挂起 */ static final int SIGNAL = -1; /** waitStatus 的值，表示线程正在等待条件 */ static final int CONDITION = -2; /** * waitStatus 的值，表示下一个acquireShared应无条件传播 */ static final int PROPAGATE = -3; /** * 状态字段，仅接受值: * * SIGNAL:值为-1 ，后继节点的线程处于等待状态， * 而当前节点的线程如果释放了同步状态或者被取消， * 将会通知后继节点，使后继节点的线程得以运行。 * * CANCELLED:值为1，由于在同步队列中等待的 * 线程等待超时或者被中断，需要从同步队列中取消等待， * 节点进入该状态将不会变化 * * CONDITION: 值为-2，节点在等待队列中， * 节点线程等待在Condition上，当其他线程 * 对Condition调用了singal方法后，该节点 * 将会从等待队列中转移到同步队列中，加入到 * 对同步状态的获取中 * * PROPAGATE: 值为-3，表示下一次共享模式同步 * 状态获取将会无条件地传播下去 * * INITIAL: 初始状态值为0 */ volatile int waitStatus; /** * Link to predecessor node that current node/thread relies on * for checking waitStatus. Assigned during enqueuing, and nulled * out (for sake of GC) only upon dequeuing. Also, upon * cancellation of a predecessor, we short-circuit while * finding a non-cancelled one, which will always exist * because the head node is never cancelled: A node becomes * head only as a result of successful acquire. A * cancelled thread never succeeds in acquiring, and a thread only * cancels itself, not any other node. */ volatile Node prev; /** * Link to the successor node that the current node/thread * unparks upon release. Assigned during enqueuing, adjusted * when bypassing cancelled predecessors, and nulled out (for * sake of GC) when dequeued. The enq operation does not * assign next field of a predecessor until after attachment, * so seeing a null next field does not necessarily mean that * node is at end of queue. However, if a next field appears * to be null, we can scan prev's from the tail to * double-check. The next field of cancelled nodes is set to * point to the node itself instead of null, to make life * easier for isOnSyncQueue. */ volatile Node next; /** * The thread that enqueued this node. Initialized on * construction and nulled out after use. */ volatile Thread thread; /** * Link to next node waiting on condition, or the special * value SHARED. Because condition queues are accessed only * when holding in exclusive mode, we just need a simple * linked queue to hold nodes while they are waiting on * conditions. They are then transferred to the queue to * re-acquire. And because conditions can only be exclusive, * we save a field by using special value to indicate shared * mode. */ Node nextWaiter; /** * Returns true if node is waiting in shared mode. */ final boolean isShared() &#123; return nextWaiter == SHARED; &#125; /** * Returns previous node, or throws NullPointerException if null. * Use when predecessor cannot be null. The null check could * be elided, but is present to help the VM. * * @return the predecessor of this node */ final Node predecessor() throws NullPointerException &#123; Node p = prev; if (p == null) throw new NullPointerException(); else return p; &#125; Node() &#123; // Used to establish initial head or SHARED marker &#125; Node(Thread thread, Node mode) &#123; // Used by addWaiter this.nextWaiter = mode; this.thread = thread; &#125; Node(Thread thread, int waitStatus) &#123; // Used by Condition this.waitStatus = waitStatus; this.thread = thread; &#125; &#125; 3：重要的方法 1234567891011121314151617/** * Acquires in exclusive mode, ignoring interrupts. Implemented * by invoking at least once &#123;@link #tryAcquire&#125;, * returning on success. Otherwise the thread is queued, possibly * repeatedly blocking and unblocking, invoking &#123;@link * #tryAcquire&#125; until success. This method can be used * to implement method &#123;@link Lock#lock&#125;. * * @param arg the acquire argument. This value is conveyed to * &#123;@link #tryAcquire&#125; but is otherwise uninterpreted and * can represent anything you like. */ public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); &#125;","categories":[{"name":"并发包","slug":"并发包","permalink":"http://blog.amoswxz.com/categories/并发包/"}],"tags":[{"name":"队列同步器","slug":"队列同步器","permalink":"http://blog.amoswxz.com/tags/队列同步器/"}]},{"title":"HashMap面试总结篇","slug":"HashMap面试总结","date":"2018-05-29T16:00:00.000Z","updated":"2018-05-31T02:28:37.367Z","comments":true,"path":"2018/05/30/HashMap面试总结/","link":"","permalink":"http://blog.amoswxz.com/2018/05/30/HashMap面试总结/","excerpt":"","text":"一：针对hashMap面试问题做一个总结吧 1：HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，使用ConcurrentHashMap。 2：hashMap采用数组加链表的形式。如果链表的长度大于8并且capacity大于MIN_TREEIFY_CAPACITY=64才会变成红黑树。 3：hashMap默认的容量是16，默认容量并不是第一次new的时候容量就是16，而是put的时候resize()的扩容的。 4：hashMap默认的加载因子loadFactor=0.75，这个数值是对空间和时间效率的一个平衡选择。如果内存空间很多而又对时间效率要求很高，可以降低负载因子Loadfactor的值；如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。 5：hash()算法原理跟获取元素index有关。（n-1） &amp; hash 6：put()方法简介：1：根据key获取hash值，hash算法大致是key的hashCode的高16位和低16位异或。 2：判断tab元素是否为null，如果null进行扩容操作。扩容完成以后根据(n-1)&amp;hash(key)获取到元素下标。 3：根据index获取tab中的元素e，如果获取到e为空，说明该index没元素，直接赋值即可。如果获取到的e不为空，判断e.key和key是否相等，如果相等直接覆盖原来的值即可。如果不相等，判断e是否是TreeNode,如果是，根据e从红黑树查询元素。如果不是TreeNode，循环index下标的元素，判断是否有元素相等，如果有key相等直接返回。没有元素相等链表的尾节点插入元素即可，此处还会判断节点元素是否大于TREEIFY_THRESHOLD，如果大于TREEIFY_THRESHOLD转为红黑树 4：如果key已经存在，把value直接覆盖，不需要修改modCount直接返回即可。 5：如果不存在，需要modCount++；判断size++&gt;threshold，大于扩容即可。 7：get()方法简介：1:根据key获取hash。 2:根据(n-1)&amp;hash获取index 3:判断index的第一个节点元素e是否等于key 4:判断e.next是否等于空，如果不等于空，循环bin查找元素 8：resize()方法简介：1：判断oldTab.length&gt;0 2：oldTab.length&gt;0，判断oldTab是否大于最大容量MAXIMUM_CAPACITY，如果大于则threshold=Integer.MAX_VALUE。不大于就把容量扩大2倍并且比较是否大于MAXIMUM_CAPACITY，不大于则临界值扩大2倍。 3：如果oldTab.length&lt;=0，临界值大于0，说明这是第一次初始化map并且初始化map的时候指定了初始容量。这个时候会调用tableSizeFor()计算临界值。扩容的时候会把newCap=threshold。重新计算临界值=新的容量*加载因子 4：如果oldTab.length&lt;=0，临界值不大于0。容量等于默认值，临界值=默认容量*加载因子 5：循环之前的数组，判断同一个index的bin上是否有多个元素，如果只有一个元素，根据这个元素重新计算index，赋值即可。如果存在多个元素，判断元素是否是红黑树，如果是进行红黑树扩容。如果不是则进行元素移动，元素可能在原来的index。也有可能变为oldCap+index。此处移动元素的原理，就是循环bin上的元素。","categories":[{"name":"面试篇","slug":"面试篇","permalink":"http://blog.amoswxz.com/categories/面试篇/"}],"tags":[{"name":"集合源码","slug":"集合源码","permalink":"http://blog.amoswxz.com/tags/集合源码/"}]},{"title":"ArrayBlockingQueue","slug":"ArrayBlockingQueue","date":"2018-05-29T16:00:00.000Z","updated":"2018-06-04T10:22:39.209Z","comments":true,"path":"2018/05/30/ArrayBlockingQueue/","link":"","permalink":"http://blog.amoswxz.com/2018/05/30/ArrayBlockingQueue/","excerpt":"","text":"","categories":[{"name":"并发包","slug":"并发包","permalink":"http://blog.amoswxz.com/categories/并发包/"}],"tags":[{"name":"队列源码","slug":"队列源码","permalink":"http://blog.amoswxz.com/tags/队列源码/"}]},{"title":"红黑树","slug":"红黑树RBTREE","date":"2018-05-24T16:00:00.000Z","updated":"2018-06-04T10:24:28.960Z","comments":true,"path":"2018/05/25/红黑树RBTREE/","link":"","permalink":"http://blog.amoswxz.com/2018/05/25/红黑树RBTREE/","excerpt":"","text":"一：简介红黑树从本质上来说就是一颗二叉查找树，但是在二叉树的基础上增加了着色相关的性质，使得红黑树可以保证相对平衡，从而保证红黑树的增删改查的时间复杂度最坏也能达到O(log N)。 二：特点 每个节点要么是黑的，要么是红的 根节点是黑的 叶节点是黑的 如果一个节点是红的，他的两个儿子节点都是黑的 对于任一节点而言，其到叶节点树尾端NIL指针的每一条路径都包含相同数目的黑节点","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://blog.amoswxz.com/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://blog.amoswxz.com/tags/数据结构/"}]},{"title":"List遇到的坑","slug":"List开发中遇到一些坑","date":"2018-05-21T16:00:00.000Z","updated":"2018-05-24T07:12:16.694Z","comments":true,"path":"2018/05/22/List开发中遇到一些坑/","link":"","permalink":"http://blog.amoswxz.com/2018/05/22/List开发中遇到一些坑/","excerpt":"","text":"一：最近在开发过程中遇到一些问题，决定把遇到的这些问题记录下来，避免让别的小伙伴踩坑。1234ArrayList&lt;Integer&gt; list = Lists.newArrayList(1, 2, 3, 4, 5); List&lt;Integer&gt; subList = list.subList(2, 4); list.retainAll(subList); Iterator&lt;Integer&gt; iterator = subList.iterator(); 上面这段代码会出现ConcurrentModificationException。 1：先分析list.subList()这段代码 。需要特别注意17行代码，把原集合的modcont赋值给了新的集合。那么此时返回的subList的和list此时的modCount是相等的等于5。 123456789101112131415161718192021222324 public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; //检查传入的下标位置 subListRangeCheck(fromIndex, toIndex, size); return new SubList(this, 0, fromIndex, toIndex);&#125; private final AbstractList&lt;E&gt; parent; private final int parentOffset; private final int offset; int size; SubList(AbstractList&lt;E&gt; parent, int offset, int fromIndex, int toIndex) &#123; //传入的this是ArrayList，所以此时parent是ArrayList this.parent = parent; //截取开始的下标位置 this.parentOffset = fromIndex; //截取开始的下标位置 this.offset = offset + fromIndex; //截取的list的大小 this.size = toIndex - fromIndex; //将原集合的modCount赋值给新集合 this.modCount = ArrayList.this.modCount; &#125; 2：执行list.retainAll()代码的时候。list的modCount变成了8。 1234567891011121314151617181920212223242526272829303132333435363738394041public boolean retainAll(Collection&lt;?&gt; c) &#123; //判断传入的集合是否为空 Objects.requireNonNull(c); return batchRemove(c, true); &#125; private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; //获取原集合元素 final Object[] elementData = this.elementData; int r = 0, w = 0; //定义一个标志位 boolean modified = false; try &#123; //遍历原集合，如果包含这个元素，就把当前这个元素提前 for (; r &lt; size; r++) if (c.contains(elementData[r]) == complement) elementData[w++] = elementData[r]; &#125; finally &#123; // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. //只有contains出现异常的时候才会走这个if if (r != size) &#123; System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; &#125; if (w != size) &#123; // clear to let GC do its work //从w开始遍历，说明w以后的数据就不是我们想要的数据 for (int i = w; i &lt; size; i++) elementData[i] = null; //遍历了多少次，modCount加多少次 modCount += size - w; //赋值给截取后的集合大小 size = w; modified = true; &#125; &#125; return modified; &#125; 3：执行subList.iterator()调用的方法是SubList类中的方法。重点关注 12345private void checkForComodification() &#123; //ArrayList.this.modCount=8;this.modCount=5;所以会抛出异常 if (ArrayList.this.modCount != this.modCount) throw new ConcurrentModificationException(); &#125; 根据以上分析可以得出结论： ==在 subList 场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增加、删除均会产生ConcurrentModificationException 异常== 二：Arrays.asList();以下代码会抛出UnsupportedOperationException12List&lt;Integer&gt; list = Arrays.asList(1, 2, 3);list.remove(1); 1：以下是部分代码，Arrays.asList()创建对象是内部私有的ArrayList。并不是java.util.ArrayList。该ArrayList没有重写父类的 add/remove/clear等方法，所以调用上述方法会抛出 UnsupportedOperationException 异常 1234567891011121314151617 public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a); &#125; /** * @serial include */ private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, java.io.Serializable &#123; private static final long serialVersionUID = -2764017481108945198L; private final E[] a; ArrayList(E[] array) &#123; a = Objects.requireNonNull(array); &#125;&#125; 三：闲谈 Amos在面试阿里的时候，阿里的一个面试官当初就问了Amos关于二个问题。 一：并发修改List会报什么错。当时一脸懵逼，只知道会报错，但是不知道报什么错==ConcurrentModificationException。== 二：遍历list的时候怎么样才能正确的删除数据。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//错误的写法，这里调用str.remove改变了modCount的值，所以报错ConcurrentModificationException ArrayList&lt;Integer&gt; str = Lists.newArrayList(); str.add(1); str.add(2); str.add(3); //此时iterator中的expactModCount=3 Iterator&lt;Integer&gt; iterator = str.iterator(); while (iterator.hasNext()) &#123; Integer next = iterator.next(); if (next == 1) &#123; //调用remove以后modCount=3+1 所以下一次调用iterator.next的时候报错 str.remove(next); &#125; &#125;//错误的写法 foreach循环底层用的还是iterator ArrayList&lt;Integer&gt; str = Lists.newArrayList(); str.add(1); str.add(2); str.add(3); for (Integer s : str) &#123; if (s == 1) &#123; str.remove(s); &#125; &#125; //正确写法一 ArrayList&lt;Integer&gt; str = Lists.newArrayList(); str.add(1); str.add(2); str.add(3); //此时iterator中的expactModCount=3 Iterator&lt;Integer&gt; iterator = str.iterator(); while (iterator.hasNext()) &#123; Integer next = iterator.next(); if (next == 1) &#123; //调用remove以后modCount=3+1 所以下一次调用iterator.next的时候报错 //这里使用iterator调用 这里改变了cursor下标，改变了expectModCount的值，所以不出现 ConcurrentModificationException iterator.remove(next); &#125; &#125; //正确写法二 这里使用倒序删除，取巧。避免了漏掉。也可以使用正序删除，改变下标 ArrayList&lt;Integer&gt; str = Lists.newArrayList(); str.add(1); str.add(2); str.add(3); str.add(5); str.add(6); for(int i = intList.size() - 1; i &gt;= 0; i--) &#123; Integer value = intList.get(i); if(value == 3 || value == 5) &#123; intList.remove(i); &#125; &#125;","categories":[{"name":"集合源码","slug":"集合源码","permalink":"http://blog.amoswxz.com/categories/集合源码/"}],"tags":[{"name":"集合源码","slug":"集合源码","permalink":"http://blog.amoswxz.com/tags/集合源码/"}]},{"title":"Iterator和Iterable","slug":"Iterator和Iterable","date":"2018-05-20T16:00:00.000Z","updated":"2018-05-21T06:49:12.965Z","comments":true,"path":"2018/05/21/Iterator和Iterable/","link":"","permalink":"http://blog.amoswxz.com/2018/05/21/Iterator和Iterable/","excerpt":"","text":"一： Iterator和Iterable都是接口,Iterable接口中定义Iterator1234567891011121314151617181920212223242526package java.util;import java.util.function.Consumer;public interface Iterator&lt;E&gt; &#123; /** * 判断是否下一个元素 */ boolean hasNext(); /** * 获取下一个元素 */ E next(); default void remove() &#123; throw new UnsupportedOperationException(\"remove\"); &#125; default void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); while (hasNext()) action.accept(next()); &#125;&#125; 12345678910111213141516171819202122232425262728package java.lang;import java.util.Iterator;import java.util.Objects;import java.util.Spliterator;import java.util.Spliterators;import java.util.function.Consumer;public interface Iterable&lt;T&gt; &#123; /** * Returns an iterator over elements of type &#123;@code T&#125;. * * @return an Iterator. */ Iterator&lt;T&gt; iterator(); default void forEach(Consumer&lt;? super T&gt; action) &#123; Objects.requireNonNull(action); for (T t : this) &#123; action.accept(t); &#125; &#125; default Spliterator&lt;T&gt; spliterator() &#123; return Spliterators.spliteratorUnknownSize(iterator(), 0); &#125;&#125; 二：为什么集合类都是实现Iterable接口而不是实现Iterator​ 1：如果实现Iterator接口，势必导致集合对象中包含当前迭代位置的数据(指针)。 当集合在不同方法间被传递时，由于当前迭代位置不可预置，那么next()方法的结果会变成不可预知。 除非再为Iterator接口添加一个reset()方法，用来重置当前迭代位置。 但即时这样，Collection也只能同时存在一个当前迭代位置。 而Iterable则不然，每次调用都会返回一个从头开始计数的迭代器（新的迭代器）。 多个迭代器是互不干扰的。这句话的意思就是。有一个成员变量集合，两个方法使用这个集合，同时遍历的时候，会导致next()方法的结果未知。","categories":[{"name":"集合源码","slug":"集合源码","permalink":"http://blog.amoswxz.com/categories/集合源码/"}],"tags":[{"name":"集合源码","slug":"集合源码","permalink":"http://blog.amoswxz.com/tags/集合源码/"}]},{"title":"集合源码篇（HashMap）","slug":"HashMap","date":"2018-05-20T16:00:00.000Z","updated":"2018-06-04T03:38:50.551Z","comments":true,"path":"2018/05/21/HashMap/","link":"","permalink":"http://blog.amoswxz.com/2018/05/21/HashMap/","excerpt":"","text":"一：HashMap简介（1.8） 1： HashMap存储结构 2：HashMap：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。 二：源码解析1：成员变量 bin(是hashmap专用术语，约定桶后面存放的每一个数据称为bin ) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 /** * 默认的初始容量，必须是2的幂 */ static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 /** * 最大的容量。1073741824 必须是2的幂 */ static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; /** * 没有指定的时候默认加载因子 默认的负载因子0.75是对空间和时间效率的一个平衡选择 * 如果内存空间很多而又对时间效率要求很高，可以降低负载因子Loadfactor的值； * 如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。 */ static final float DEFAULT_LOAD_FACTOR = 0.75f; /** * bin转为红黑树判断条件之一 bin数量大于8 */ static final int TREEIFY_THRESHOLD = 8; /** *由树转换成链表的阈值UNTREEIFY_THRESHOLD *当执行resize操作时，当桶中bin的数量少于UNTREEIFY_THRESHOLD时使用链表来代替树。默认值是6 */ static final int UNTREEIFY_THRESHOLD = 6; /** * 如果bin中的数量大于TREEIFY_THRESHOLD，但是capacity小于MIN_TREEIFY_CAPACITY，依然使用链 表存储。此时会进行resize操作;如果capacity大于MIN_TREEIFY_CAPACITY进行树化 */ static final int MIN_TREEIFY_CAPACITY = 64;/** *存放KV数据的数组。第一次使用的时候被初始化，根据需要可以重新resize。分配的长度总是2的幂。 */ transient Node&lt;K,V&gt;[] table; /** * 当被调用entrySet时被赋值。通过keySet()方法可以得到map key的集合，通过values方法可以得到map * value的集合。 */ transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; /** * map的大小 */ transient int size; /** * 结构修改的次数 */ transient int modCount; /** * 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容 */ int threshold; /** * 填充因子 */ final float loadFactor; 3：构造函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * @param initialCapacity 初始容量 * @param loadFactor 填充因子 */ public HashMap(int initialCapacity, float loadFactor) &#123; //容量小于0抛出illega异常 if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); //如果初始容量大于1&lt;&lt;30 那么容量大小就等于1&lt;&lt;30 if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; //如果加载因子小于等于0或者不是float类型 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); //赋值填充因子 this.loadFactor = loadFactor; //临界值 刚开始以为这样写是一个Bug， //觉得应该这样写this.threshold = tableSizeFor(initialCapacity) * this.loadFactor; //此处带着疑问去看put方法，就会明白此处为啥这么设计。这里是懒加载。并没有new的时候直接加载 //找到大于等于initialCapacity的最小的2的幂 this.threshold = tableSizeFor(initialCapacity); &#125; /** * @param initialCapacity 初始容量 * 使用默认的加载因子 */ public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; /** * 默认容量16，默认加载因子0.75 */ public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted &#125; /** * 传入一个map,使用默认加载因子 */ public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; //这个方法下文putAll的时候会详细介绍 putMapEntries(m, false); &#125; 4：常用方法介绍4.1：put()方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 /*** @param key* @param value*/ public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125; /***这里就是低16位和高16位异或。为什么要这么做呢？...与hashTable计算下标有关。*/ static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; /** * @param key hash以后的值 * @param key * @param value * @param onlyIfAbsent true:不改变存在的值;false:改变存在的值 * @param evict if false, the table is in creation mode. * @return 返回老的值或者空 */ final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //判断节点数组是否为null,是null进行扩容 ;不等于null,把节点长度赋值给n,节点长度为0扩容 if ((tab = table) == null || (n = tab.length) == 0) //进行扩容操作，并把扩容后的长度赋值给n n = (tab = resize()).length; // (tab.length-1)&amp;hash 得到index 。注意，同一个元素在扩容前后可能得到的index不一样 if ((p = tab[i = (n - 1) &amp; hash]) == null) //如果等于null，直接newNode，放入tab;不等于null,p=当前下标得到的第一个bin tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; //判断第一个节点是否等于当前元素，如果等于赋值给e。 if (p.hash == hash &amp;&amp;((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //判断p是否是treeNode，如果是红黑树，则添加数据。红黑树的crud有文章介绍 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; //循环查找元素 for (int binCount = 0; ; ++binCount) &#123; //获取p的下一个bin if ((e = p.next) == null) &#123; //构建一个新的节点，把地址赋值给上个记得点的next指针域 p.next = newNode(hash, key, value, null); //判断bin数量是否大于8。这里减1因为binCount是从0开始的 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st //转为红黑树。 //如果容量小于MIN_TREEIFY_CAPACITY，不会进行树化，会进行扩容 treeifyBin(tab, hash); break; &#125; //判断元素是否等于当前元素。和上面同理 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; //e不等于空，说明之前已经存在这个key if (e != null) &#123; // existing mapping for key //获取老的值 V oldValue = e.value; //onlyIfAbsent=fals 或者oldValue=null 改变存在的值。返回老的值 if (!onlyIfAbsent || oldValue == null) e.value = value; //这个方法是为了LinkedHashMap服务的 afterNodeAccess(e); return oldValue; &#125; &#125; //改变了结构，modCount加1 ++modCount; //判断size+1 是否大于临界值，大于扩容 if (++size &gt; threshold) resize(); //这个方法是为了LinkedHashMap服务的 afterNodeInsertion(evict); return null; &#125; 4.2：resize()方法，借用了网上一张图片 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/** * 初始化table,或者table的大小扩大两倍。如果是table空，根据tableSizeFor方法计算出threshold的值，然后赋值给capacity，然后重新计算threshold=capacit*loadFactor。如果table不为空。根据2的幂来扩容，原来bin的元素要么在原来的位置或者从原来的位置移动到（原索引+oldCap）。扩容以后看新增hash值的bit位是1,index=（原索引+oldCap）,否则就是原来的index位置 */ final Node&lt;K,V&gt;[] resize() &#123; //当前table赋值给oldTab Node&lt;K,V&gt;[] oldTab = table; //获取老的table长度 int oldCap = (oldTab == null) ? 0 : oldTab.length; //当前的threshold赋值给oldThr int oldThr = threshold; //定义新的容量，新的临界值 int newCap, newThr = 0; //如果老的容量大于0 if (oldCap &gt; 0) &#123; //老的容量大于最大容量 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; //临界值等于Integer.MAX_VALUE threshold = Integer.MAX_VALUE; return oldTab; &#125; //oldCap扩大2倍赋值给newCap,比较newCap是否小于最大容量 并且oldCap大于等于默认容量 //如果满足，oldThr扩大两倍赋值给newThr else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; //如果oldThr大于0，说明初始化map的传入了初始容量 else if (oldThr &gt; 0) // initial capacity was placed in threshold //oldThr赋值给newCap newCap = oldThr; else &#123; // zero initial threshold signifies using defaults //进入此处，说明new HashMap的时候没有指定容量。 //赋值默认容量，临界值等于默认容量*默认加载因子 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; //如果newThr等于0，说明oldThr大于0； if (newThr == 0) &#123; //新的容量*加载因子得到新的临界值 float ft = (float)newCap * loadFactor; //赋值newThr newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; //临界值赋值给threshold threshold = newThr; @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) //定义新的table数组，指定长度为newCap Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; //newTab赋值给table table = newTab; //判断oldTab是否等于null if (oldTab != null) &#123; //循环oldCap，把老的元素重新放入newCap for (int j = 0; j &lt; oldCap; ++j) &#123; //定义e元素 Node&lt;K,V&gt; e; //获取j位置的索引赋值给e，判断oldTab是否等于空 if ((e = oldTab[j]) != null) &#123; //把下标为j的元素置为空 oldTab[j] = null; //判断e后面是否还有元素 if (e.next == null) //把e放入newTab 新的index处 newTab[e.hash &amp; (newCap - 1)] = e; //判断e是否是红黑树，此处不细讲。后面会讲 else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order //以下代码作用保护排序和元素移动。 //元素移动：把oldTab中的元素挂到newTab中。这里需要注意的是，元素的位置可能不变， 也有可能变为(原索引+oldCap) //定义节点元素。lohead代表index不变的元素 Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; //e的下一个元素赋值给next next = e.next; //判断bin中元素的index是否变化，如果==0说明index没变。 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; //不等于0说明index=index+oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); //将节点元素放入数组中 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; //将节点元素放入j+oldCap if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; 4.3：get()方法 1234567891011121314151617181920212223242526272829303132333435363738394041/** * 传入key */ public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; &#125;/** * * @param 对key进行hash * @param key the key * @return the node, or null if none */ final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; //定义Node数组；定义一个节点first,e;定义n,定义一个K类型的k Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; //判断，如果table不等于null,table的长度大于0,根据计算出来的index获取table元素不等于null if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; //这里总是检查第一个元素，我也不知道为啥这么检查。有知道的朋友可以分享一下 //判断第一个元素的hash和传入key的hash是否相等并且判断传入的key等于first的key if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) //返回第一个节点元素 return first; //判断first节点下是否还挂着其它节点 if ((e = first.next) != null) &#123; //判断是否树化 if (first instanceof TreeNode) //从红黑树中查找 return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; //循环查找，没有找到返回null if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null; &#125; 4.4：putAll()方法 123456789101112131415161718192021222324252627282930313233343536373839 /** * 拷贝传入的元素到map */public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123; putMapEntries(m, true); &#125; /** * @param m the map * @param evict 是false代表是构造方法的时候调用这个，如果是true代表是其它方法 */ final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123; //获取map的大小 int s = m.size(); //如果size大于0 if (s &gt; 0) &#123; //判断table是否为null if (table == null) &#123; // pre-size //使用s/loadFactor+1.0 其实是为了获得table的容量 float ft = ((float)s / loadFactor) + 1.0F; //比较容量是否超过最大值 int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); //扩大临界值 if (t &gt; threshold) threshold = tableSizeFor(t); &#125; //扩容判断 else if (s &gt; threshold) resize(); //循环添加 for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123; K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); &#125; &#125; &#125; 4.5：remove()方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 @Override public boolean remove(Object key, Object value) &#123; return removeNode(hash(key), key, value, true, true) != null; &#125;/** * * @param hash hash以后的值 * @param key the key * @param value 如果matchValue是true,才使用value,其它忽略 * @param matchValue 如果true必须value，key相等才能删除 only remove if value is equal * @param movable 如果false删除的时候不移动节点 * @return the node, or null if none */ final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; //定义一个tab,定义一个Node Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; //table不等于null并且table长度大于0，根据index获取table元素不等于null if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; //定义变量 Node&lt;K,V&gt; node = null, e; K k; V v; //判断第一个节点是否key是否相等，如果相等 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) //赋值node node = p; //判断下一个节点元素是否 else if ((e = p.next) != null) &#123; //判断p是否是红黑树 if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else &#123; //循环bin判断key是否存在 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; //node不等于null，说明根据这个key找到了这个元素。判断value是否相等 if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; //判断是否是红黑树 if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); //判断node是否是第一个元素。如果是获取node的下一个元素赋值给tab[index] else if (node == p) tab[index] = node.next; else //不是第一个元素。从p元素口面删除node元素 p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; &#125; &#125; return null; &#125; 4.6：keySet()和Values() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100 // 返回此映射中包含的键的map视图 // 解惑：最开始在看这段代码的时候并没有看懂。 // 1：此处直接返回了一个包含key的Set集合，但是又没有对map的key进行处理，所以一直在纠结这里是怎么处理的。最后在同事的指点下，幡然大悟。 // 2：这里只是返回了一个包含map的视图，对这个集合进行遍历的时候会调用iterator方法。iteraotr方法会调用new KeyIterator()；KeyIterator这个类继承了hashIterator。 //3：遍历set集合的时候会调用next方法。next方法会调用HashIterator的NextNode方法。下面对nextNode方法做了介绍 public Set&lt;K&gt; keySet() &#123; Set&lt;K&gt; ks = keySet; if (ks == null) &#123; ks = new KeySet(); keySet = ks; &#125; return ks; &#125; final class KeySet extends AbstractSet&lt;K&gt; &#123; public final int size() &#123; return size; &#125; public final void clear() &#123; HashMap.this.clear(); &#125; public final Iterator&lt;K&gt; iterator() &#123; return new KeyIterator(); &#125; public final boolean contains(Object o) &#123; return containsKey(o); &#125; public final boolean remove(Object key) &#123; return removeNode(hash(key), key, null, false, true) != null; &#125; public final Spliterator&lt;K&gt; spliterator() &#123; return new KeySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); &#125; public final void forEach(Consumer&lt;? super K&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.key); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; &#125; final class KeyIterator extends HashIterator implements Iterator&lt;K&gt; &#123; public final K next() &#123; return nextNode().key; &#125; &#125; abstract class HashIterator &#123; Node&lt;K,V&gt; next; // next entry to return Node&lt;K,V&gt; current; // current entry int expectedModCount; // for fast-fail int index; // current slot//调用iterator的方法的时候会初始化HashIterator HashIterator() &#123; //把map中的modCount赋值给expectedModCount expectedModCount = modCount; //table赋值给t Node&lt;K,V&gt;[] t = table; current = next = null; index = 0; //找到一个bin元素不为空就返回 if (t != null &amp;&amp; size &gt; 0) &#123; // advance to first entry do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); &#125; &#125; public final boolean hasNext() &#123; return next != null; &#125;//nextNode方法 此处就是循环查找next元素 final Node&lt;K,V&gt; nextNode() &#123; //定义t Node&lt;K,V&gt;[] t; //把next元素赋值给e Node&lt;K,V&gt; e = next; //判断线性结构的修改 if (modCount != expectedModCount) throw new ConcurrentModificationException(); if (e == null) throw new NoSuchElementException(); //如果bin上还有节点直接返回下一个节点。如果没有循环则循环table查找下一个index的node元素 if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) &#123; do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); &#125; return e; &#125; public final void remove() &#123; Node&lt;K,V&gt; p = current; if (p == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); current = null; K key = p.key; removeNode(hash(key), key, null, false, false); expectedModCount = modCount; &#125; &#125; haspMap其它方法就不一一介绍。下一篇文章会对hashMap进行总结以及面试会被问的问题。","categories":[{"name":"集合源码","slug":"集合源码","permalink":"http://blog.amoswxz.com/categories/集合源码/"}],"tags":[{"name":"集合源码","slug":"集合源码","permalink":"http://blog.amoswxz.com/tags/集合源码/"}]},{"title":"集合源码篇（LinkedList）","slug":"LinkedList","date":"2018-05-03T16:00:00.000Z","updated":"2018-05-08T15:16:46.027Z","comments":true,"path":"2018/05/04/LinkedList/","link":"","permalink":"http://blog.amoswxz.com/2018/05/04/LinkedList/","excerpt":"","text":"###LinkedList简介 LinkedList是基于链表的，是线程不安全的，允许为null。增删只需要修改节点指针，所以增删时间效率很高，不需要扩容，也不需要预留空间。缺点就是随机访问的时候，效率很低。 ## LinkedList类关系图 从图可以看出LinkedList实现了deque。可以作为一个双端队列来使用。不支持随机访问 源码解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123; transient int size = 0; /** * 头结点 */ transient Node&lt;E&gt; first; /** * 指向最后一个节点的引用 */ transient Node&lt;E&gt; last; /** * 空的构造方法. */ public LinkedList() &#123; &#125; /** *有参构造 */ public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125; /** * Node的结构. */ private static class Node&lt;E&gt; &#123; E item; //下个节点的指针域 Node&lt;E&gt; next; //上个节点的指针域 Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125; /** * LinkedList默认采用的是尾插法. */ void linkLast(E e) &#123; //尾节点的引用赋值给零食变量l final Node&lt;E&gt; l = last; //构建新节点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); //新节点赋值给尾节点引用 last = newNode; //尾节点引用为空，说明第一次添加节点 if (l == null) first = newNode; else //尾节点的next域指针指向新节点 l.next = newNode; size++; modCount++; &#125; /** * 头插法.插入第一个元素 */ private void linkFirst(E e) &#123; //将头节点赋值临时变量f final Node&lt;E&gt; f = first; //构建新节点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); //将新节点赋值给头结点 first = newNode; //如果头结点为空，新节点就是头结点 if (f == null) last = newNode; else //新节点赋值给上一个节点的前指针 f.prev = newNode; size++; modCount++; &#125; /** * 判断元素的位置 从头开始查找 */ public int indexOf(Object o) &#123; //定义下标 int index = 0; //判断o是否为空 if (o == null) &#123; //从头节点开始查找 for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; //从尾节点开始查找 for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1; &#125; /** * 新增元素。index表示从下标index开始新增。c表示集合 */ public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; //判断index是否大于等于0并且小于等于size checkPositionIndex(index); //集合转数组 Object[] a = c.toArray(); //数组长度 int numNew = a.length; //如果等于0说明传入的是一个空集合 if (numNew == 0) return false; Node&lt;E&gt; pred, succ; //从尾节点开始添加 if (index == size) &#123; succ = null; pred = last; &#125; else &#123; //这里是一个二分查找。succ是index位置的节点 succ = node(index); //获取index节点的上一个指针 pred = succ.prev; &#125; //循环添加元素，添加完成以后pred是最后一个节点 for (Object o : a) &#123; @SuppressWarnings(\"unchecked\") E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); if (pred == null) first = newNode; else pred.next = newNode; pred = newNode; &#125; if (succ == null) &#123; //最后一个节点引用赋值 last = pred; &#125; else &#123; //如果不是尾插，就把插入完成后的节点跟之前的节点拼接 //现在pred是最后一个节点。把succ赋值给pred节点的next pred.next = succ; succ.prev = pred; &#125; size += numNew; modCount++; return true; &#125; &#125;","categories":[{"name":"集合源码","slug":"集合源码","permalink":"http://blog.amoswxz.com/categories/集合源码/"}],"tags":[{"name":"集合源码","slug":"集合源码","permalink":"http://blog.amoswxz.com/tags/集合源码/"}]},{"title":"集合源码篇（ArrayList）","slug":"ArrayList","date":"2018-04-17T16:00:00.000Z","updated":"2018-05-22T17:24:17.074Z","comments":true,"path":"2018/04/18/ArrayList/","link":"","permalink":"http://blog.amoswxz.com/2018/04/18/ArrayList/","excerpt":"","text":"ArrayList简介ArrayList是基于数组实现的，是一个动态数组。容量可以自动增加动态增长内存。 ArrayList是线程不安全的，只能在单线程环境下使用。多线程环境下使用juc下面的CopyOnWriteArrayList（后续会介绍） ArrayList类关系图 从该图可以看到，ArrayList继承AbstractList类，AbstractList类实现List接口；ArrayList实现了List接口。有人就会问，为什么ArrayList既要继承AbstractList又实现了List接口呢。这是因为java集合框架用到了很多适配器模式，用AbstractList去实现List接口，这样ArrayList继承AbstractList只需要重写自己需要的方法即可，不用实现接口中的所有方法。实现了randomAccess接口，RandomAccess 是一个空的接口，它用来标识某个类是否支持 随机访问（随机访问，相对比“按顺序访问”）。一个支持随机访问的类明显可以使用更加高效的算法。 源码解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package java.util;import java.util.function.Consumer;import java.util.function.Predicate;import java.util.function.UnaryOperator; /**很多人往往忽略了类上面的注释，其实这个注释才是最重要的。上面注释大概介绍了几点 *1：ArrayList是List接口的大小可变数组实现的，实现了List中接口中的所有方法。允许元素为null。 *2：时间复杂度：size()，isEmpty()，get()，set()，iterator()，listIterator()，这些操作时间复杂度是 o(1)。 因为是根据数组下标实现的。可以根据索引直接定位到元素位置。add()，remove()方法的时间复杂度是o(n)。因为添加删除元素需要移动元素位置。 *3：ArrayList容量可以自动增长 *4：ArrayList不是同步的，并发修改会返回fail-fast。会抛出ConcurrentModificationException**/public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; private static final long serialVersionUID = 8683452581122892189L; /** * Default initial capacity. * 默认初始化容量 */ private static final int DEFAULT_CAPACITY = 10; /** * 指定ArrayList容量为0时，返回该空数组 */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; /** * 调用无参构造的时候返回该对象。与EMPTY_ELEMENTDATA的区别在于 * 指定容量大小为0返回EMPTY_ELEMENTDATA。默认返回DEFAULTCAPACITY_EMPTY_ELEMENTDATA */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; /** * 保存到ArrayList中元素，ArrayList的容量就是数组大小 * 第一次添加元素到ArrayList，该数组扩容为默认的大小DEFAULT_CAPACITY * transient 被标记表示不可序列化 */ transient Object[] elementData; // non-private to simplify nested class access /** * The size of the ArrayList (the number of elements it contains). * * @serial * ArrayList的大小 */ private int size;&#125; ArrayList提供了三个构造函数 初始化一个空数组：注意这里并不是初始化容量为10的数组 初始化一个collection 元素列表。将collection转为数组，判断数组大小是否为0，如果是0返回EMPTY_ELEMENTDATA。否则返回的是重新创建的数组并且数组大小是传入的collection大小. 注意事项： c.toArray might (incorrectly) not return Object[] (see 6260652) 这里其实是一个JDK1.8的bug ；这个bug的意思就是 Arrays.asList(x).toArray().getClass() should be Object[].class 但是返回的是class [Ljava.lang.String；jdk9已经修复。 Arrays.copy方法调用的是 这里为什么要判断((Object)newType == (Object)Object[].class) 如果是Object直接静态创建，在Array.newInstance中创建新实例的原因很可能是性能选择，如果程序总是需要创建新实例，那么它将比直接初始化一个通用对象数组和复制东西更加昂贵。Stack Overflow 上面有对该代码的解释 ArrayList中方法介绍 trimToSize()方法 1234567891011/** * 优化数组大小，只保留存储添加进去元素的空间 */ public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125; &#125; add()方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 public boolean add(E e) &#123; //当前size+1 ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; private void ensureCapacityInternal(int minCapacity) &#123;//判断当前元素是否等于空 第一次执行add的时候执行才会是true if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; //当前容量和默认容量10比较，取大的值 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; //结构修改次数；该变量主要是用来实现fail-fast机制的 modCount++; // overflow-conscious code //当前size+1大于数组容量进行扩容 if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; /** * * 增加容量以确保它至少能容纳。* 最小容量参数指定的元素个数。 */ private void grow(int minCapacity) &#123; // overflow-conscious code // 获取老的数组大小 int oldCapacity = elementData.length; //新的数组大小=1.5倍老的数组大小 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 第一次扩容的时候才会用到，即第一次add的时候 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; /**为什么要减去8呢？ *因为某些JVM会在数组中保留一些头字，尝试分配这个最大存储容量，可能会导致array容量大于JVM的限制，最终导致OutOfMemoryError。 *判断数组容量是否达到Integer.MAX_VALUE - 8,达到就返回Integer.MAX_VALUE - 8**/ if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); //数组扩容 elementData = Arrays.copyOf(elementData, newCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; iterator()方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; private class Itr implements Iterator&lt;E&gt; &#123; //访问下一个元素的索引 int cursor; // index of next element to return //访问上一个元素的索引 int lastRet = -1; // index of last element returned; -1 if no such //ArrayList修改次数 int expectedModCount = modCount; //判断是否有下一个元素 public boolean hasNext() &#123; return cursor != size; &#125;//获取下一个元素 @SuppressWarnings(\"unchecked\") public E next() &#123; //检查集合内容是否被修改 checkForComodification(); int i = cursor; //下一个元素的下标等于size说明没有元素 if (i &gt;= size) throw new NoSuchElementException(); //获取ArrayList中数据 Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; //删除元素 ArrayList.this.remove(lastRet); //删除元素的下标给下一个元素 cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings(\"unchecked\") public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125;","categories":[{"name":"集合源码","slug":"集合源码","permalink":"http://blog.amoswxz.com/categories/集合源码/"}],"tags":[{"name":"集合源码","slug":"集合源码","permalink":"http://blog.amoswxz.com/tags/集合源码/"}]},{"title":"数据结构（Queue）","slug":"Queue","date":"2018-04-16T16:00:00.000Z","updated":"2018-06-04T10:24:28.955Z","comments":true,"path":"2018/04/17/Queue/","link":"","permalink":"http://blog.amoswxz.com/2018/04/17/Queue/","excerpt":"","text":"1：Queue简介1.1：队列先进先出（First Input First Output），队列是一种特殊的线性表，特殊之处在于只允许从表的前端删除，后端插入。进行插入操作的称为队尾。进行删除操作的叫队头。 2：类关系图 Queue继承Collection,Collection继承Iterable。 1234567891011121314151617181920212223242526272829303132333435package java.util;public interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123; /** *增加一个元素 */ boolean add(E e); /** *添加一个元素并返回true */ boolean offer(E e); /** *移除并返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常 */ E remove(); /** *移除并返问队列头部的元素，如果队列为空，则返回null */ E poll(); /** *返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常 */ E element(); /** * 返回队列头部的元素，如果队列为空，则返回null */ E peek();&#125; 下图是借用网上的，觉得画的很好。接下来的文章会一一介绍这些队列。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://blog.amoswxz.com/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://blog.amoswxz.com/tags/数据结构/"}]},{"title":"数据结构（ADT）","slug":"data-structure-introduction","date":"2018-04-16T16:00:00.000Z","updated":"2018-06-04T10:24:28.949Z","comments":true,"path":"2018/04/17/data-structure-introduction/","link":"","permalink":"http://blog.amoswxz.com/2018/04/17/data-structure-introduction/","excerpt":"","text":"一：什么是数据结构： 数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。 二：常用的数据结构（大致的介绍，后面会详细介绍） 1：数组（Array）是包含类似数据类型元素的对象。这是我们存储相似元素的数据结构。我们只能将一组固定的元素存储在java数组中。java中的数组是基于索引的，数组的第一个元素存储在0索引处。查询快；插入删除慢、内存连续、数组大小固定。 1.1：数组在heap中是分配的内存是连续的。如果查找直接按照索引查询即可。如果想要在2,3中插入4，那么就设计到元素的扩容和元素的移动 2：栈（Stack）LIFO 先进后出 3：队列（Queue）FIFO 先进先出 4：链表：链表也是线性表的一种，实际有Node节点组成，物理存储结构上不连续，逻辑上连续；大小不固定。查询慢；插入查找快 4.1：下图展示的是一个单向链表，其中有两个元素，数据域，值域。头指针：我们把指向头节点的指针域成为头指针。头指针是必须存在的。头结点：很多时候，会在链表的头部附加一个结点，该结点的数据域可以不存储任何信息，这个结点称为头结点。头节点值域可以为空，指针域指向下一个节点，最后一个节点的指针域为空。ps：双端链表就是头结点有个引用直接指向最后一个节点。双端链表的好处在于。比如在尾部插入一个结点，双端链表可以进行直接操作但单向链表只能通过next节点循环找到最后结点操作。 4.2：下图展示的是一个双向列表 5：树（Tree） 6：图（Graph） 7：堆（Heap） 8：散列表（Hash）","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://blog.amoswxz.com/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://blog.amoswxz.com/tags/数据结构/"}]},{"title":"Hexo快速搭建博客(二)","slug":"hexo1","date":"2018-04-15T16:00:00.000Z","updated":"2018-04-25T06:51:21.855Z","comments":true,"path":"2018/04/16/hexo1/","link":"","permalink":"http://blog.amoswxz.com/2018/04/16/hexo1/","excerpt":"","text":"一：经常看到别人的博客域名是 username.github.io，这个域名是怎么来的呢？ 1：在github上创建username.github.io的repository的仓库 二：把本地项目上传到创建的username.github.io这个repository。 1：为hexo安装git插件 1npm install hexo-deployer-git --save 2：在项目的根目录_config.yml中配置 12345deploy: type: git repo: git@github.com:amoswxz/AmosWxz.github.io.git branch: master message: &quot;测试&quot; 3：执行命令 1hexo clean(删除生成的public文件夹) 1hexo generate(生成public文件夹) 1执行hexo deploy(上传静态文件到github) 4：网页访问username.github.io的即可","categories":[{"name":"Hexo搭建博客","slug":"Hexo搭建博客","permalink":"http://blog.amoswxz.com/categories/Hexo搭建博客/"}],"tags":[{"name":"Hexo搭建博客","slug":"Hexo搭建博客","permalink":"http://blog.amoswxz.com/tags/Hexo搭建博客/"}]},{"title":"Hexo快速搭建博客(一)","slug":"hexo","date":"2018-04-13T16:00:00.000Z","updated":"2018-04-25T06:51:21.864Z","comments":true,"path":"2018/04/14/hexo/","link":"","permalink":"http://blog.amoswxz.com/2018/04/14/hexo/","excerpt":"","text":"一：hexo是什么？ Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 二：安装hexo 1：安装git,楼主使用的是 brew 安装的 执行：brew install git 2：安装node 和 npm 执行：brew install node 3：执行 npm install -g hexo-cli ; npm的源在国外,建议修改npm源, 楼主使用的淘宝的源。执行npm config set registry https://registry.npm.taobao.org 。查看npm使用的源 npm config get registry 4：hexo init blog 初始化博客项目 5：执行 npm install 安装依赖 6：执行 hexo server 启动项目 访问即可 7：hexo init blog 使用的是默认主题 landscape,这个主题可能不是那么的beautiful;我们可以更换主题。楼主使用的是anatole主题。如果想要更换主题直接clone主题到项目的themes文件夹。更改项目根目录_config.yml中theme的值即可","categories":[{"name":"Hexo搭建博客","slug":"Hexo搭建博客","permalink":"http://blog.amoswxz.com/categories/Hexo搭建博客/"}],"tags":[{"name":"Hexo搭建博客","slug":"Hexo搭建博客","permalink":"http://blog.amoswxz.com/tags/Hexo搭建博客/"}]}]}