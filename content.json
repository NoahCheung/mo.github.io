{"meta":{"title":"Amos","subtitle":"Amos","description":"记录Amos成长路上点点滴滴~","author":"John Doe","url":"http://blog.amoswxz.com"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2018-04-23T16:43:30.052Z","updated":"2018-04-23T16:09:49.000Z","comments":false,"path":"/404.html","permalink":"http://blog.amoswxz.com//404.html","excerpt":"","text":""},{"title":"关于","date":"2018-04-25T03:28:52.046Z","updated":"2018-04-24T06:02:16.655Z","comments":false,"path":"about/index.html","permalink":"http://blog.amoswxz.com/about/index.html","excerpt":"","text":"个人详细介绍 12345678910111213141516171819202122232425262728&#123; name: '王小中' age: 22, gender: '男', profession: 'java开发', experience: '3年', address: '北京朝阳', education: '专科', github: 'https://github.com/amoswxz', blog: 'http://amoswxz.com', email: 'amoswxz@gmail.com', description: '后端开发，喜爱Java，乐于全栈', skills: [ ['Java', 'Python'], ['Spring', 'SpringBoot','SpringCloud','Mybatis'], ['Mysql', 'Oracle'], ['Git', 'SVN'], ['Docker'], ['React'], ], devTools: [ ['Intellij IDEA', 'DataGrip'， 'WebStorm', 'PyCharm', 'Sublime Text'], ['Chrome DevTools'], ['Iterm'], ] &#125;"},{"title":"书单","date":"2018-04-23T17:13:19.914Z","updated":"2018-04-23T17:13:19.913Z","comments":false,"path":"books/index.html","permalink":"http://blog.amoswxz.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-04-24T14:26:15.829Z","updated":"2018-04-24T14:26:15.827Z","comments":false,"path":"categories/index.html","permalink":"http://blog.amoswxz.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-04-23T16:58:58.491Z","updated":"2018-04-23T16:58:58.490Z","comments":false,"path":"links/index.html","permalink":"http://blog.amoswxz.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2018-04-25T03:28:52.757Z","updated":"2018-04-23T17:13:19.907Z","comments":false,"path":"repository/index.html","permalink":"http://blog.amoswxz.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-04-24T14:23:53.937Z","updated":"2018-04-24T14:23:53.936Z","comments":false,"path":"tags/index.html","permalink":"http://blog.amoswxz.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"集合源码篇（LinkedList）","slug":"LinkedList","date":"2018-04-24T16:00:00.000Z","updated":"2018-04-25T06:51:21.867Z","comments":true,"path":"2018/04/25/LinkedList/","link":"","permalink":"http://blog.amoswxz.com/2018/04/25/LinkedList/","excerpt":"","text":"","categories":[{"name":"集合源码","slug":"集合源码","permalink":"http://blog.amoswxz.com/categories/集合源码/"}],"tags":[{"name":"集合源码","slug":"集合源码","permalink":"http://blog.amoswxz.com/tags/集合源码/"}]},{"title":"集合源码篇（ArrayList）","slug":"ArrayList","date":"2018-04-17T16:00:00.000Z","updated":"2018-04-25T06:52:20.167Z","comments":true,"path":"2018/04/18/ArrayList/","link":"","permalink":"http://blog.amoswxz.com/2018/04/18/ArrayList/","excerpt":"","text":"ArrayList简介ArrayList是基于数组实现的，是一个动态数组。容量可以自动增加动态增长内存。 ArrayList是线程不安全的，只能在单线程环境下使用。多线程环境下使用juc下面的CopyOnWriteArrayList（后续会介绍） ArrayList类关系继承图 从该图可以看到，ArrayList继承AbstractList类，AbstractList类实现List接口；ArrayList实现了List接口。有人就会问，为什么ArrayList既要继承AbstractList又实现了List接口呢。这是因为java集合框架用到了很多适配器模式，用AbstractList去实现List接口，这样ArrayList继承AbstractList只需要重写自己需要的方法即可，不用实现接口中的所有方法。实现了randomAccess接口，RandomAccess 是一个空的接口，它用来标识某个类是否支持 随机访问（随机访问，相对比“按顺序访问”）。一个支持随机访问的类明显可以使用更加高效的算法。 源码解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package java.util;import java.util.function.Consumer;import java.util.function.Predicate;import java.util.function.UnaryOperator; /**很多人往往忽略了类上面的注释，其实这个注释才是最重要的。上面注释大概介绍了几点 *1：ArrayList是List接口的大小可变数组实现的，实现了List中接口中的所有方法。允许元素为null。 *2：时间复杂度：size()，isEmpty()，get()，set()，iterator()，listIterator()，这些操作时间复杂度是 o(1)。 因为是根据数组下标实现的。可以根据索引直接定位到元素位置。add()，remove()方法的时间复杂度是o(n)。因为添加删除元素需要移动元素位置。 *3：ArrayList容量可以自动增长 *4：ArrayList不是同步的，并发修改会返回fail-fast。会抛出ConcurrentModificationException**/public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; private static final long serialVersionUID = 8683452581122892189L; /** * Default initial capacity. * 默认初始化容量 */ private static final int DEFAULT_CAPACITY = 10; /** * 指定ArrayList容量为0时，返回该空数组 */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; /** * 调用无参构造的时候返回该对象。与EMPTY_ELEMENTDATA的区别在于 * 指定容量大小为0返回EMPTY_ELEMENTDATA。默认返回DEFAULTCAPACITY_EMPTY_ELEMENTDATA */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; /** * 保存到ArrayList中元素，ArrayList的容量就是数组大小 * 第一次添加元素到ArrayList，该数组扩容为默认的大小DEFAULT_CAPACITY * transient 被标记表示不可序列化 */ transient Object[] elementData; // non-private to simplify nested class access /** * The size of the ArrayList (the number of elements it contains). * * @serial * ArrayList的大小 */ private int size;&#125; ArrayList提供了三个构造函数 初始化一个空数组：注意这里并不是初始化容量为10的数组 初始化一个collection 元素列表。将collection转为数组，判断数组大小是否为0，如果是0返回EMPTY_ELEMENTDATA。否则返回的是重新创建的数组并且数组大小是传入的collection大小. 注意事项： c.toArray might (incorrectly) not return Object[] (see 6260652) 这里其实是一个JDK1.8的bug ；这个bug的意思就是 Arrays.asList(x).toArray().getClass() should be Object[].class 但是返回的是class [Ljava.lang.String；jdk9已经修复。 Arrays.copy方法调用的是 这里为什么要判断((Object)newType == (Object)Object[].class) 如果是Object直接静态创建，在Array.newInstance中创建新实例的原因很可能是性能选择，如果程序总是需要创建新实例，那么它将比直接初始化一个通用对象数组和复制东西更加昂贵。Stack Overflow 上面有对该代码的解释 ArrayList中方法介绍 trimToSize()方法 1234567891011/** * 优化数组大小，只保留存储添加进去元素的空间 */ public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125; &#125; add()方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 public boolean add(E e) &#123; //当前size+1 ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; private void ensureCapacityInternal(int minCapacity) &#123;//判断当前元素是否等于空 第一次执行add的时候执行才会是true if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; //当前容量和默认容量10比较，取大的值 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; //结构修改次数；该变量主要是用来实现fail-fast机制的 modCount++; // overflow-conscious code //当前size+1大于数组容量进行扩容 if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; /** * * 增加容量以确保它至少能容纳。* 最小容量参数指定的元素个数。 */ private void grow(int minCapacity) &#123; // overflow-conscious code // 获取老的数组大小 int oldCapacity = elementData.length; //新的数组大小=1.5倍老的数组大小 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 第一次扩容的时候才会用到，即第一次add的时候 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; /**为什么要减去8呢？ *因为某些JVM会在数组中保留一些头字，尝试分配这个最大存储容量，可能会导致array容量大于JVM的限制，最终导致OutOfMemoryError。 *判断数组容量是否达到Integer.MAX_VALUE - 8,达到就返回Integer.MAX_VALUE - 8**/ if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); //数组扩容 elementData = Arrays.copyOf(elementData, newCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; iterator()方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; private class Itr implements Iterator&lt;E&gt; &#123; //访问下一个元素的索引 int cursor; // index of next element to return //访问上一个元素的索引 int lastRet = -1; // index of last element returned; -1 if no such //ArrayList修改次数 int expectedModCount = modCount; //判断是否有下一个元素 public boolean hasNext() &#123; return cursor != size; &#125;//获取下一个元素 @SuppressWarnings(\"unchecked\") public E next() &#123; //检查集合内容是否被修改 checkForComodification(); int i = cursor; //下一个元素的下标等于size说明没有元素 if (i &gt;= size) throw new NoSuchElementException(); //获取ArrayList中数据 Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; //删除元素 ArrayList.this.remove(lastRet); //删除元素的下标给下一个元素 cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings(\"unchecked\") public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; Amos在面试阿里的时候，阿里的一个面试官当初就问了Amos关于二个问题。 一：并发修改List会报什么错。当时一脸懵逼，只知道会报错，但是不知道报什么错==ConcurrentModificationException。== 二：遍历list的时候怎么样才能正确的删除数据。 1234567891011121314151617181920212223242526272829303132333435363738394041//错误的写法，这里调用str.remove改变了modCount的值，所以报错ConcurrentModificationException ArrayList&lt;Integer&gt; str = Lists.newArrayList(); str.add(1); str.add(2); str.add(3); //此时iterator中的expactModCount=3 Iterator&lt;Integer&gt; iterator = str.iterator(); while (iterator.hasNext()) &#123; Integer next = iterator.next(); if (next == 1) &#123; //调用remove以后modCount=3+1 所以下一次调用iterator.next的时候报错 str.remove(next); &#125; &#125;//错误的写法 foreach循环底层用的还是iterator ArrayList&lt;Integer&gt; str = Lists.newArrayList(); str.add(1); str.add(2); str.add(3); for (Integer s : str) &#123; if (s == 1) &#123; str.remove(s); &#125; &#125;//正确写法一 ArrayList&lt;Integer&gt; str = Lists.newArrayList(); str.add(1); str.add(2); str.add(3); //此时iterator中的expactModCount=3 Iterator&lt;Integer&gt; iterator = str.iterator(); while (iterator.hasNext()) &#123; Integer next = iterator.next(); if (next == 1) &#123; //调用remove以后modCount=3+1 所以下一次调用iterator.next的时候报错 //这里使用iterator调用 这里改变了cursor下标，改变了expectModCount的值，所以不出现ConcurrentModificationException iterator.remove(next); &#125; &#125;//也可以使用for循环删除。删除某个元素后，list的大小发生了变化，而你的索引也在变化，所以会导致你在遍历的时候漏掉某些元素","categories":[{"name":"集合源码","slug":"集合源码","permalink":"http://blog.amoswxz.com/categories/集合源码/"}],"tags":[{"name":"集合源码","slug":"集合源码","permalink":"http://blog.amoswxz.com/tags/集合源码/"}]},{"title":"数据结构简介（ADT）","slug":"data-structure-introduction","date":"2018-04-16T16:00:00.000Z","updated":"2018-04-26T03:47:43.991Z","comments":true,"path":"2018/04/17/data-structure-introduction/","link":"","permalink":"http://blog.amoswxz.com/2018/04/17/data-structure-introduction/","excerpt":"","text":"一：什么是数据结构： 数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。 二：常用的数据结构（大致的介绍，后面会详细介绍） 1：数组（Array）是包含类似数据类型元素的对象。这是我们存储相似元素的数据结构。我们只能将一组固定的元素存储在java数组中。java中的数组是基于索引的，数组的第一个元素存储在0索引处。查询快；插入删除慢、内存连续、数组大小固定。 1.1：数组在heap中是分配的内存是连续的。如果查找直接按照索引查询即可。如果想要在2,3中插入4，那么就设计到元素的扩容和元素的移动 2：栈（Stack）LIFO 先进后出 3：队列（Queue）FIFO 先进先出 4：链表：链表也是线性表的一种，实际有Node节点组成，在内存中可以不是连续的。查询慢；插入查找快 4.1：下图展示的是一个单向链表，头节点值域为空，指针域指向下一个节点，最后一个节点的指针域为空。 ​ ps：双端链表就是头结点有个引用直接指向最后一个节点。双端链表的好处在于。比如在尾部插入一个结点，双端链表可以进行直接操作但单向链表只能通过next节点循环找到最后结点操作。 4.2：下图展示的是一个双向列表 5：树（Tree） 6：图（Graph） 7：堆（Heap） 8：散列表（Hash）","categories":[{"name":"数据结构简介","slug":"数据结构简介","permalink":"http://blog.amoswxz.com/categories/数据结构简介/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://blog.amoswxz.com/tags/数据结构/"}]},{"title":"Hexo快速搭建博客(二)","slug":"hexo1","date":"2018-04-15T16:00:00.000Z","updated":"2018-04-25T06:51:21.855Z","comments":true,"path":"2018/04/16/hexo1/","link":"","permalink":"http://blog.amoswxz.com/2018/04/16/hexo1/","excerpt":"","text":"一：经常看到别人的博客域名是 username.github.io，这个域名是怎么来的呢？ 1：在github上创建username.github.io的repository的仓库 二：把本地项目上传到创建的username.github.io这个repository。 1：为hexo安装git插件 1npm install hexo-deployer-git --save 2：在项目的根目录_config.yml中配置 12345deploy: type: git repo: git@github.com:amoswxz/AmosWxz.github.io.git branch: master message: &quot;测试&quot; 3：执行命令 1hexo clean(删除生成的public文件夹) 1hexo generate(生成public文件夹) 1执行hexo deploy(上传静态文件到github) 4：网页访问username.github.io的即可","categories":[{"name":"Hexo搭建博客","slug":"Hexo搭建博客","permalink":"http://blog.amoswxz.com/categories/Hexo搭建博客/"}],"tags":[{"name":"Hexo搭建博客","slug":"Hexo搭建博客","permalink":"http://blog.amoswxz.com/tags/Hexo搭建博客/"}]},{"title":"Hexo快速搭建博客(一)","slug":"hexo","date":"2018-04-13T16:00:00.000Z","updated":"2018-04-25T06:51:21.864Z","comments":true,"path":"2018/04/14/hexo/","link":"","permalink":"http://blog.amoswxz.com/2018/04/14/hexo/","excerpt":"","text":"一：hexo是什么？ Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 二：安装hexo 1：安装git,楼主使用的是 brew 安装的 执行：brew install git 2：安装node 和 npm 执行：brew install node 3：执行 npm install -g hexo-cli ; npm的源在国外,建议修改npm源, 楼主使用的淘宝的源。执行npm config set registry https://registry.npm.taobao.org 。查看npm使用的源 npm config get registry 4：hexo init blog 初始化博客项目 5：执行 npm install 安装依赖 6：执行 hexo server 启动项目 访问即可 7：hexo init blog 使用的是默认主题 landscape,这个主题可能不是那么的beautiful;我们可以更换主题。楼主使用的是anatole主题。如果想要更换主题直接clone主题到项目的themes文件夹。更改项目根目录_config.yml中theme的值即可","categories":[{"name":"Hexo搭建博客","slug":"Hexo搭建博客","permalink":"http://blog.amoswxz.com/categories/Hexo搭建博客/"}],"tags":[{"name":"Hexo搭建博客","slug":"Hexo搭建博客","permalink":"http://blog.amoswxz.com/tags/Hexo搭建博客/"}]}]}