{"meta":{"title":"Amos","subtitle":"Amos","description":"记录Amos成长路上点点滴滴~","author":"John Doe","url":"http://blog.amoswxz.com"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2018-05-07T15:35:19.422Z","updated":"2018-05-07T15:35:19.404Z","comments":false,"path":"/404.html","permalink":"http://blog.amoswxz.com//404.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-04-23T16:58:58.491Z","updated":"2018-04-23T16:58:58.490Z","comments":false,"path":"links/index.html","permalink":"http://blog.amoswxz.com/links/index.html","excerpt":"","text":""},{"title":"关于","date":"2018-05-04T08:51:18.880Z","updated":"2018-04-24T06:02:16.655Z","comments":false,"path":"about/index.html","permalink":"http://blog.amoswxz.com/about/index.html","excerpt":"","text":"个人详细介绍 12345678910111213141516171819202122232425262728&#123; name: '王小中' age: 22, gender: '男', profession: 'java开发', experience: '3年', address: '北京朝阳', education: '专科', github: 'https://github.com/amoswxz', blog: 'http://amoswxz.com', email: 'amoswxz@gmail.com', description: '后端开发，喜爱Java，乐于全栈', skills: [ ['Java', 'Python'], ['Spring', 'SpringBoot','SpringCloud','Mybatis'], ['Mysql', 'Oracle'], ['Git', 'SVN'], ['Docker'], ['React'], ], devTools: [ ['Intellij IDEA', 'DataGrip'， 'WebStorm', 'PyCharm', 'Sublime Text'], ['Chrome DevTools'], ['Iterm'], ] &#125;"},{"title":"Repositories","date":"2018-05-04T08:51:14.693Z","updated":"2018-04-23T17:13:19.907Z","comments":false,"path":"repository/index.html","permalink":"http://blog.amoswxz.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-04-24T14:23:53.937Z","updated":"2018-04-24T14:23:53.936Z","comments":false,"path":"tags/index.html","permalink":"http://blog.amoswxz.com/tags/index.html","excerpt":"","text":""},{"title":"书单","date":"2018-05-07T15:35:19.423Z","updated":"2018-04-23T17:13:19.913Z","comments":false,"path":"books/index.html","permalink":"http://blog.amoswxz.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-04-24T14:26:15.829Z","updated":"2018-04-24T14:26:15.827Z","comments":false,"path":"categories/index.html","permalink":"http://blog.amoswxz.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"List遇到的坑","slug":"List开发中遇到一些坑","date":"2018-05-21T16:00:00.000Z","updated":"2018-05-24T07:12:16.694Z","comments":true,"path":"2018/05/22/List开发中遇到一些坑/","link":"","permalink":"http://blog.amoswxz.com/2018/05/22/List开发中遇到一些坑/","excerpt":"","text":"一：最近在开发过程中遇到一些问题，决定把遇到的这些问题记录下来，避免让别的小伙伴踩坑。1234ArrayList&lt;Integer&gt; list = Lists.newArrayList(1, 2, 3, 4, 5); List&lt;Integer&gt; subList = list.subList(2, 4); list.retainAll(subList); Iterator&lt;Integer&gt; iterator = subList.iterator(); 上面这段代码会出现ConcurrentModificationException。 1：先分析list.subList()这段代码 。需要特别注意17行代码，把原集合的modcont赋值给了新的集合。那么此时返回的subList的和list此时的modCount是相等的等于5。 123456789101112131415161718192021222324 public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; //检查传入的下标位置 subListRangeCheck(fromIndex, toIndex, size); return new SubList(this, 0, fromIndex, toIndex);&#125; private final AbstractList&lt;E&gt; parent; private final int parentOffset; private final int offset; int size; SubList(AbstractList&lt;E&gt; parent, int offset, int fromIndex, int toIndex) &#123; //传入的this是ArrayList，所以此时parent是ArrayList this.parent = parent; //截取开始的下标位置 this.parentOffset = fromIndex; //截取开始的下标位置 this.offset = offset + fromIndex; //截取的list的大小 this.size = toIndex - fromIndex; //将原集合的modCount赋值给新集合 this.modCount = ArrayList.this.modCount; &#125; 2：执行list.retainAll()代码的时候。list的modCount变成了8。 1234567891011121314151617181920212223242526272829303132333435363738394041public boolean retainAll(Collection&lt;?&gt; c) &#123; //判断传入的集合是否为空 Objects.requireNonNull(c); return batchRemove(c, true); &#125; private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; //获取原集合元素 final Object[] elementData = this.elementData; int r = 0, w = 0; //定义一个标志位 boolean modified = false; try &#123; //遍历原集合，如果包含这个元素，就把当前这个元素提前 for (; r &lt; size; r++) if (c.contains(elementData[r]) == complement) elementData[w++] = elementData[r]; &#125; finally &#123; // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. //只有contains出现异常的时候才会走这个if if (r != size) &#123; System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; &#125; if (w != size) &#123; // clear to let GC do its work //从w开始遍历，说明w以后的数据就不是我们想要的数据 for (int i = w; i &lt; size; i++) elementData[i] = null; //遍历了多少次，modCount加多少次 modCount += size - w; //赋值给截取后的集合大小 size = w; modified = true; &#125; &#125; return modified; &#125; 3：执行subList.iterator()调用的方法是SubList类中的方法。重点关注 12345private void checkForComodification() &#123; //ArrayList.this.modCount=8;this.modCount=5;所以会抛出异常 if (ArrayList.this.modCount != this.modCount) throw new ConcurrentModificationException(); &#125; 根据以上分析可以得出结论： ==在 subList 场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增加、删除均会产生ConcurrentModificationException 异常== 二：Arrays.asList();以下代码会抛出UnsupportedOperationException12List&lt;Integer&gt; list = Arrays.asList(1, 2, 3);list.remove(1); 1：以下是部分代码，Arrays.asList()创建对象是内部私有的ArrayList。并不是java.util.ArrayList。该ArrayList没有重写父类的 add/remove/clear等方法，所以调用上述方法会抛出 UnsupportedOperationException 异常 1234567891011121314151617 public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a); &#125; /** * @serial include */ private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, java.io.Serializable &#123; private static final long serialVersionUID = -2764017481108945198L; private final E[] a; ArrayList(E[] array) &#123; a = Objects.requireNonNull(array); &#125;&#125; 三：闲谈 Amos在面试阿里的时候，阿里的一个面试官当初就问了Amos关于二个问题。 一：并发修改List会报什么错。当时一脸懵逼，只知道会报错，但是不知道报什么错==ConcurrentModificationException。== 二：遍历list的时候怎么样才能正确的删除数据。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//错误的写法，这里调用str.remove改变了modCount的值，所以报错ConcurrentModificationException ArrayList&lt;Integer&gt; str = Lists.newArrayList(); str.add(1); str.add(2); str.add(3); //此时iterator中的expactModCount=3 Iterator&lt;Integer&gt; iterator = str.iterator(); while (iterator.hasNext()) &#123; Integer next = iterator.next(); if (next == 1) &#123; //调用remove以后modCount=3+1 所以下一次调用iterator.next的时候报错 str.remove(next); &#125; &#125;//错误的写法 foreach循环底层用的还是iterator ArrayList&lt;Integer&gt; str = Lists.newArrayList(); str.add(1); str.add(2); str.add(3); for (Integer s : str) &#123; if (s == 1) &#123; str.remove(s); &#125; &#125; //正确写法一 ArrayList&lt;Integer&gt; str = Lists.newArrayList(); str.add(1); str.add(2); str.add(3); //此时iterator中的expactModCount=3 Iterator&lt;Integer&gt; iterator = str.iterator(); while (iterator.hasNext()) &#123; Integer next = iterator.next(); if (next == 1) &#123; //调用remove以后modCount=3+1 所以下一次调用iterator.next的时候报错 //这里使用iterator调用 这里改变了cursor下标，改变了expectModCount的值，所以不出现 ConcurrentModificationException iterator.remove(next); &#125; &#125; //正确写法二 这里使用倒序删除，取巧。避免了漏掉。也可以使用正序删除，改变下标 ArrayList&lt;Integer&gt; str = Lists.newArrayList(); str.add(1); str.add(2); str.add(3); str.add(5); str.add(6); for(int i = intList.size() - 1; i &gt;= 0; i--) &#123; Integer value = intList.get(i); if(value == 3 || value == 5) &#123; intList.remove(i); &#125; &#125;","categories":[{"name":"集合源码","slug":"集合源码","permalink":"http://blog.amoswxz.com/categories/集合源码/"}],"tags":[{"name":"集合源码","slug":"集合源码","permalink":"http://blog.amoswxz.com/tags/集合源码/"}]},{"title":"Iterator和Iterable","slug":"Iterator和Iterable","date":"2018-05-20T16:00:00.000Z","updated":"2018-05-21T06:49:12.965Z","comments":true,"path":"2018/05/21/Iterator和Iterable/","link":"","permalink":"http://blog.amoswxz.com/2018/05/21/Iterator和Iterable/","excerpt":"","text":"一： Iterator和Iterable都是接口,Iterable接口中定义Iterator1234567891011121314151617181920212223242526package java.util;import java.util.function.Consumer;public interface Iterator&lt;E&gt; &#123; /** * 判断是否下一个元素 */ boolean hasNext(); /** * 获取下一个元素 */ E next(); default void remove() &#123; throw new UnsupportedOperationException(\"remove\"); &#125; default void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); while (hasNext()) action.accept(next()); &#125;&#125; 12345678910111213141516171819202122232425262728package java.lang;import java.util.Iterator;import java.util.Objects;import java.util.Spliterator;import java.util.Spliterators;import java.util.function.Consumer;public interface Iterable&lt;T&gt; &#123; /** * Returns an iterator over elements of type &#123;@code T&#125;. * * @return an Iterator. */ Iterator&lt;T&gt; iterator(); default void forEach(Consumer&lt;? super T&gt; action) &#123; Objects.requireNonNull(action); for (T t : this) &#123; action.accept(t); &#125; &#125; default Spliterator&lt;T&gt; spliterator() &#123; return Spliterators.spliteratorUnknownSize(iterator(), 0); &#125;&#125; 二：为什么集合类都是实现Iterable接口而不是实现Iterator​ 1：如果实现Iterator接口，势必导致集合对象中包含当前迭代位置的数据(指针)。 当集合在不同方法间被传递时，由于当前迭代位置不可预置，那么next()方法的结果会变成不可预知。 除非再为Iterator接口添加一个reset()方法，用来重置当前迭代位置。 但即时这样，Collection也只能同时存在一个当前迭代位置。 而Iterable则不然，每次调用都会返回一个从头开始计数的迭代器（新的迭代器）。 多个迭代器是互不干扰的。这句话的意思就是。有一个成员变量集合，两个方法使用这个集合，同时遍历的时候，会导致next()方法的结果未知。","categories":[{"name":"集合源码","slug":"集合源码","permalink":"http://blog.amoswxz.com/categories/集合源码/"}],"tags":[{"name":"集合源码","slug":"集合源码","permalink":"http://blog.amoswxz.com/tags/集合源码/"}]},{"title":"集合源码篇（HashMap）","slug":"HashMap","date":"2018-05-20T16:00:00.000Z","updated":"2018-05-21T17:09:29.032Z","comments":true,"path":"2018/05/21/HashMap/","link":"","permalink":"http://blog.amoswxz.com/2018/05/21/HashMap/","excerpt":"","text":"一：HashMap简介 1： HashMap存储结构 2：HashMap：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。 二：源码解析1：成员变量 bin(是hashmap专用术语，约定桶后面存放的每一个数据称为bin ) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 /** * 默认的初始容量，必须是2的幂 */ static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 /** * 最大的容量。1073741824 必须是2的幂 */ static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; /** * 没有指定的时候默认加载因子 默认的负载因子0.75是对空间和时间效率的一个平衡选择 * 如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值； * 如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。 */ static final float DEFAULT_LOAD_FACTOR = 0.75f; /** * bin转为红黑树判断条件之一 bin数量大于8 */ static final int TREEIFY_THRESHOLD = 8; /** *由树转换成链表的阈值UNTREEIFY_THRESHOLD *当执行resize操作时，当桶中bin的数量少于UNTREEIFY_THRESHOLD时使用链表来代替树。默认值是6 */ static final int UNTREEIFY_THRESHOLD = 6; /** * 如果bin中的数量大于TREEIFY_THRESHOLD，但是capacity小于MIN_TREEIFY_CAPACITY，依然使用链 表存储。此时会对hashmap resize;如果capacity大于MIN_TREEIFY_CAPACITY进行树化 */ static final int MIN_TREEIFY_CAPACITY = 64;/** *存放KV数据的数组。第一次使用的时候被初始化，根据需要可以重新resize。分配的长度总是2的幂。 */ transient Node&lt;K,V&gt;[] table; /** * 当被调用entrySet时被赋值。通过keySet()方法可以得到map key的集合，通过values方法可以得到map * value的集合。 */ transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; /** * map的大小 */ transient int size; /** * 结构修改的次数 */ transient int modCount; /** * 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容 */ int threshold; /** * 填充因子 */ final float loadFactor; 2：内部数据结构Node 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Basic hash bin node, used for most entries. (See below for * TreeNode subclass, and in LinkedHashMap for its Entry subclass.) */ static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + \"=\" + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125; &#125; 3：构造函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * @param 默认容量 * @param 填充因子 */ public HashMap(int initialCapacity, float loadFactor) &#123; //容量小于0抛出illega异常 if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); //如果初始容量大于1&lt;&lt;30 那么容量大小就等于1&lt;&lt;30 if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; //如果加载因子小于等于0或者不是float类型 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); //赋值填充因子 this.loadFactor = loadFactor; //临界值=容量*填充因子。tableSizeFor采用的是位运算 this.threshold = tableSizeFor(initialCapacity); &#125; /** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and the default load factor (0.75). * * @param initialCapacity the initial capacity. * @throws IllegalArgumentException if the initial capacity is negative. */ public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; /** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity * (16) and the default load factor (0.75). */ public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted &#125; /** * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the * specified &lt;tt&gt;Map&lt;/tt&gt;. The &lt;tt&gt;HashMap&lt;/tt&gt; is created with * default load factor (0.75) and an initial capacity sufficient to * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;. * * @param m the map whose mappings are to be placed in this map * @throws NullPointerException if the specified map is null */ public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false); &#125;","categories":[{"name":"集合源码","slug":"集合源码","permalink":"http://blog.amoswxz.com/categories/集合源码/"}],"tags":[{"name":"集合源码","slug":"集合源码","permalink":"http://blog.amoswxz.com/tags/集合源码/"}]},{"title":"集合源码篇（LinkedList）","slug":"LinkedList","date":"2018-05-03T16:00:00.000Z","updated":"2018-05-08T15:16:46.027Z","comments":true,"path":"2018/05/04/LinkedList/","link":"","permalink":"http://blog.amoswxz.com/2018/05/04/LinkedList/","excerpt":"","text":"###LinkedList简介 LinkedList是基于链表的，是线程不安全的，允许为null。增删只需要修改节点指针，所以增删时间效率很高，不需要扩容，也不需要预留空间。缺点就是随机访问的时候，效率很低。 ## LinkedList类关系图 从图可以看出LinkedList实现了deque。可以作为一个双端队列来使用。不支持随机访问 源码解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123; transient int size = 0; /** * 头结点 */ transient Node&lt;E&gt; first; /** * 指向最后一个节点的引用 */ transient Node&lt;E&gt; last; /** * 空的构造方法. */ public LinkedList() &#123; &#125; /** *有参构造 */ public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125; /** * Node的结构. */ private static class Node&lt;E&gt; &#123; E item; //下个节点的指针域 Node&lt;E&gt; next; //上个节点的指针域 Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125; /** * LinkedList默认采用的是尾插法. */ void linkLast(E e) &#123; //尾节点的引用赋值给零食变量l final Node&lt;E&gt; l = last; //构建新节点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); //新节点赋值给尾节点引用 last = newNode; //尾节点引用为空，说明第一次添加节点 if (l == null) first = newNode; else //尾节点的next域指针指向新节点 l.next = newNode; size++; modCount++; &#125; /** * 头插法.插入第一个元素 */ private void linkFirst(E e) &#123; //将头节点赋值临时变量f final Node&lt;E&gt; f = first; //构建新节点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); //将新节点赋值给头结点 first = newNode; //如果头结点为空，新节点就是头结点 if (f == null) last = newNode; else //新节点赋值给上一个节点的前指针 f.prev = newNode; size++; modCount++; &#125; /** * 判断元素的位置 从头开始查找 */ public int indexOf(Object o) &#123; //定义下标 int index = 0; //判断o是否为空 if (o == null) &#123; //从头节点开始查找 for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; //从尾节点开始查找 for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1; &#125; /** * 新增元素。index表示从下标index开始新增。c表示集合 */ public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; //判断index是否大于等于0并且小于等于size checkPositionIndex(index); //集合转数组 Object[] a = c.toArray(); //数组长度 int numNew = a.length; //如果等于0说明传入的是一个空集合 if (numNew == 0) return false; Node&lt;E&gt; pred, succ; //从尾节点开始添加 if (index == size) &#123; succ = null; pred = last; &#125; else &#123; //这里是一个二分查找。succ是index位置的节点 succ = node(index); //获取index节点的上一个指针 pred = succ.prev; &#125; //循环添加元素，添加完成以后pred是最后一个节点 for (Object o : a) &#123; @SuppressWarnings(\"unchecked\") E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); if (pred == null) first = newNode; else pred.next = newNode; pred = newNode; &#125; if (succ == null) &#123; //最后一个节点引用赋值 last = pred; &#125; else &#123; //如果不是尾插，就把插入完成后的节点跟之前的节点拼接 //现在pred是最后一个节点。把succ赋值给pred节点的next pred.next = succ; succ.prev = pred; &#125; size += numNew; modCount++; return true; &#125; &#125;","categories":[{"name":"集合源码","slug":"集合源码","permalink":"http://blog.amoswxz.com/categories/集合源码/"}],"tags":[{"name":"集合源码","slug":"集合源码","permalink":"http://blog.amoswxz.com/tags/集合源码/"}]},{"title":"集合源码篇（ArrayList）","slug":"ArrayList","date":"2018-04-17T16:00:00.000Z","updated":"2018-05-22T17:24:17.074Z","comments":true,"path":"2018/04/18/ArrayList/","link":"","permalink":"http://blog.amoswxz.com/2018/04/18/ArrayList/","excerpt":"","text":"ArrayList简介ArrayList是基于数组实现的，是一个动态数组。容量可以自动增加动态增长内存。 ArrayList是线程不安全的，只能在单线程环境下使用。多线程环境下使用juc下面的CopyOnWriteArrayList（后续会介绍） ArrayList类关系图 从该图可以看到，ArrayList继承AbstractList类，AbstractList类实现List接口；ArrayList实现了List接口。有人就会问，为什么ArrayList既要继承AbstractList又实现了List接口呢。这是因为java集合框架用到了很多适配器模式，用AbstractList去实现List接口，这样ArrayList继承AbstractList只需要重写自己需要的方法即可，不用实现接口中的所有方法。实现了randomAccess接口，RandomAccess 是一个空的接口，它用来标识某个类是否支持 随机访问（随机访问，相对比“按顺序访问”）。一个支持随机访问的类明显可以使用更加高效的算法。 源码解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package java.util;import java.util.function.Consumer;import java.util.function.Predicate;import java.util.function.UnaryOperator; /**很多人往往忽略了类上面的注释，其实这个注释才是最重要的。上面注释大概介绍了几点 *1：ArrayList是List接口的大小可变数组实现的，实现了List中接口中的所有方法。允许元素为null。 *2：时间复杂度：size()，isEmpty()，get()，set()，iterator()，listIterator()，这些操作时间复杂度是 o(1)。 因为是根据数组下标实现的。可以根据索引直接定位到元素位置。add()，remove()方法的时间复杂度是o(n)。因为添加删除元素需要移动元素位置。 *3：ArrayList容量可以自动增长 *4：ArrayList不是同步的，并发修改会返回fail-fast。会抛出ConcurrentModificationException**/public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; private static final long serialVersionUID = 8683452581122892189L; /** * Default initial capacity. * 默认初始化容量 */ private static final int DEFAULT_CAPACITY = 10; /** * 指定ArrayList容量为0时，返回该空数组 */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; /** * 调用无参构造的时候返回该对象。与EMPTY_ELEMENTDATA的区别在于 * 指定容量大小为0返回EMPTY_ELEMENTDATA。默认返回DEFAULTCAPACITY_EMPTY_ELEMENTDATA */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; /** * 保存到ArrayList中元素，ArrayList的容量就是数组大小 * 第一次添加元素到ArrayList，该数组扩容为默认的大小DEFAULT_CAPACITY * transient 被标记表示不可序列化 */ transient Object[] elementData; // non-private to simplify nested class access /** * The size of the ArrayList (the number of elements it contains). * * @serial * ArrayList的大小 */ private int size;&#125; ArrayList提供了三个构造函数 初始化一个空数组：注意这里并不是初始化容量为10的数组 初始化一个collection 元素列表。将collection转为数组，判断数组大小是否为0，如果是0返回EMPTY_ELEMENTDATA。否则返回的是重新创建的数组并且数组大小是传入的collection大小. 注意事项： c.toArray might (incorrectly) not return Object[] (see 6260652) 这里其实是一个JDK1.8的bug ；这个bug的意思就是 Arrays.asList(x).toArray().getClass() should be Object[].class 但是返回的是class [Ljava.lang.String；jdk9已经修复。 Arrays.copy方法调用的是 这里为什么要判断((Object)newType == (Object)Object[].class) 如果是Object直接静态创建，在Array.newInstance中创建新实例的原因很可能是性能选择，如果程序总是需要创建新实例，那么它将比直接初始化一个通用对象数组和复制东西更加昂贵。Stack Overflow 上面有对该代码的解释 ArrayList中方法介绍 trimToSize()方法 1234567891011/** * 优化数组大小，只保留存储添加进去元素的空间 */ public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125; &#125; add()方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 public boolean add(E e) &#123; //当前size+1 ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; private void ensureCapacityInternal(int minCapacity) &#123;//判断当前元素是否等于空 第一次执行add的时候执行才会是true if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; //当前容量和默认容量10比较，取大的值 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; //结构修改次数；该变量主要是用来实现fail-fast机制的 modCount++; // overflow-conscious code //当前size+1大于数组容量进行扩容 if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; /** * * 增加容量以确保它至少能容纳。* 最小容量参数指定的元素个数。 */ private void grow(int minCapacity) &#123; // overflow-conscious code // 获取老的数组大小 int oldCapacity = elementData.length; //新的数组大小=1.5倍老的数组大小 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 第一次扩容的时候才会用到，即第一次add的时候 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; /**为什么要减去8呢？ *因为某些JVM会在数组中保留一些头字，尝试分配这个最大存储容量，可能会导致array容量大于JVM的限制，最终导致OutOfMemoryError。 *判断数组容量是否达到Integer.MAX_VALUE - 8,达到就返回Integer.MAX_VALUE - 8**/ if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); //数组扩容 elementData = Arrays.copyOf(elementData, newCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; iterator()方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; private class Itr implements Iterator&lt;E&gt; &#123; //访问下一个元素的索引 int cursor; // index of next element to return //访问上一个元素的索引 int lastRet = -1; // index of last element returned; -1 if no such //ArrayList修改次数 int expectedModCount = modCount; //判断是否有下一个元素 public boolean hasNext() &#123; return cursor != size; &#125;//获取下一个元素 @SuppressWarnings(\"unchecked\") public E next() &#123; //检查集合内容是否被修改 checkForComodification(); int i = cursor; //下一个元素的下标等于size说明没有元素 if (i &gt;= size) throw new NoSuchElementException(); //获取ArrayList中数据 Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; //删除元素 ArrayList.this.remove(lastRet); //删除元素的下标给下一个元素 cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings(\"unchecked\") public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125;","categories":[{"name":"集合源码","slug":"集合源码","permalink":"http://blog.amoswxz.com/categories/集合源码/"}],"tags":[{"name":"集合源码","slug":"集合源码","permalink":"http://blog.amoswxz.com/tags/集合源码/"}]},{"title":"数据结构简介（Queue）","slug":"Queue","date":"2018-04-16T16:00:00.000Z","updated":"2018-05-13T08:52:15.717Z","comments":true,"path":"2018/04/17/Queue/","link":"","permalink":"http://blog.amoswxz.com/2018/04/17/Queue/","excerpt":"","text":"1：Queue简介1.1：队列先进先出（First Input First Output），队列是一种特殊的线性表，特殊之处在于只允许从表的前端删除，后端插入。进行插入操作的称为队尾。进行删除操作的叫队头。 2：类关系图 Queue继承Collection,Collection继承Iterable。 1234567891011121314151617181920212223242526272829303132333435package java.util;public interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123; /** *增加一个元素，队列已满，则抛出一个IIIegaISlabEepeplian异常 */ boolean add(E e); /** *添加一个元素并返回true，如果队列已满，则返回false */ boolean offer(E e); /** *移除并返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常 */ E remove(); /** *移除并返问队列头部的元素，如果队列为空，则返回null */ E poll(); /** *移除并返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常 */ E element(); /** * 返回队列头部的元素，如果队列为空，则返回null */ E peek();&#125;","categories":[{"name":"数据结构简介","slug":"数据结构简介","permalink":"http://blog.amoswxz.com/categories/数据结构简介/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://blog.amoswxz.com/tags/数据结构/"}]},{"title":"数据结构简介（ADT）","slug":"data-structure-introduction","date":"2018-04-16T16:00:00.000Z","updated":"2018-04-30T14:13:47.368Z","comments":true,"path":"2018/04/17/data-structure-introduction/","link":"","permalink":"http://blog.amoswxz.com/2018/04/17/data-structure-introduction/","excerpt":"","text":"一：什么是数据结构： 数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。 二：常用的数据结构（大致的介绍，后面会详细介绍） 1：数组（Array）是包含类似数据类型元素的对象。这是我们存储相似元素的数据结构。我们只能将一组固定的元素存储在java数组中。java中的数组是基于索引的，数组的第一个元素存储在0索引处。查询快；插入删除慢、内存连续、数组大小固定。 1.1：数组在heap中是分配的内存是连续的。如果查找直接按照索引查询即可。如果想要在2,3中插入4，那么就设计到元素的扩容和元素的移动 2：栈（Stack）LIFO 先进后出 3：队列（Queue）FIFO 先进先出 4：链表：链表也是线性表的一种，实际有Node节点组成，物理存储结构上不连续，逻辑上连续；大小不固定。查询慢；插入查找快 4.1：下图展示的是一个单向链表，其中有两个元素，数据域，值域。头指针：我们把指向头节点的指针域成为头指针。头指针是必须存在的。头结点：很多时候，会在链表的头部附加一个结点，该结点的数据域可以不存储任何信息，这个结点称为头结点。头节点值域可以为空，指针域指向下一个节点，最后一个节点的指针域为空。ps：双端链表就是头结点有个引用直接指向最后一个节点。双端链表的好处在于。比如在尾部插入一个结点，双端链表可以进行直接操作但单向链表只能通过next节点循环找到最后结点操作。 4.2：下图展示的是一个双向列表 5：树（Tree） 6：图（Graph） 7：堆（Heap） 8：散列表（Hash）","categories":[{"name":"数据结构简介","slug":"数据结构简介","permalink":"http://blog.amoswxz.com/categories/数据结构简介/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://blog.amoswxz.com/tags/数据结构/"}]},{"title":"Hexo快速搭建博客(二)","slug":"hexo1","date":"2018-04-15T16:00:00.000Z","updated":"2018-04-25T06:51:21.855Z","comments":true,"path":"2018/04/16/hexo1/","link":"","permalink":"http://blog.amoswxz.com/2018/04/16/hexo1/","excerpt":"","text":"一：经常看到别人的博客域名是 username.github.io，这个域名是怎么来的呢？ 1：在github上创建username.github.io的repository的仓库 二：把本地项目上传到创建的username.github.io这个repository。 1：为hexo安装git插件 1npm install hexo-deployer-git --save 2：在项目的根目录_config.yml中配置 12345deploy: type: git repo: git@github.com:amoswxz/AmosWxz.github.io.git branch: master message: &quot;测试&quot; 3：执行命令 1hexo clean(删除生成的public文件夹) 1hexo generate(生成public文件夹) 1执行hexo deploy(上传静态文件到github) 4：网页访问username.github.io的即可","categories":[{"name":"Hexo搭建博客","slug":"Hexo搭建博客","permalink":"http://blog.amoswxz.com/categories/Hexo搭建博客/"}],"tags":[{"name":"Hexo搭建博客","slug":"Hexo搭建博客","permalink":"http://blog.amoswxz.com/tags/Hexo搭建博客/"}]},{"title":"Hexo快速搭建博客(一)","slug":"hexo","date":"2018-04-13T16:00:00.000Z","updated":"2018-04-25T06:51:21.864Z","comments":true,"path":"2018/04/14/hexo/","link":"","permalink":"http://blog.amoswxz.com/2018/04/14/hexo/","excerpt":"","text":"一：hexo是什么？ Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 二：安装hexo 1：安装git,楼主使用的是 brew 安装的 执行：brew install git 2：安装node 和 npm 执行：brew install node 3：执行 npm install -g hexo-cli ; npm的源在国外,建议修改npm源, 楼主使用的淘宝的源。执行npm config set registry https://registry.npm.taobao.org 。查看npm使用的源 npm config get registry 4：hexo init blog 初始化博客项目 5：执行 npm install 安装依赖 6：执行 hexo server 启动项目 访问即可 7：hexo init blog 使用的是默认主题 landscape,这个主题可能不是那么的beautiful;我们可以更换主题。楼主使用的是anatole主题。如果想要更换主题直接clone主题到项目的themes文件夹。更改项目根目录_config.yml中theme的值即可","categories":[{"name":"Hexo搭建博客","slug":"Hexo搭建博客","permalink":"http://blog.amoswxz.com/categories/Hexo搭建博客/"}],"tags":[{"name":"Hexo搭建博客","slug":"Hexo搭建博客","permalink":"http://blog.amoswxz.com/tags/Hexo搭建博客/"}]}]}