<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Amos</title>
  
  <subtitle>Amos</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.amoswxz.com/"/>
  <updated>2018-05-25T08:25:18.015Z</updated>
  <id>http://blog.amoswxz.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>红黑树</title>
    <link href="http://blog.amoswxz.com/2018/05/25/%E7%BA%A2%E9%BB%91%E6%A0%91RBTREE/"/>
    <id>http://blog.amoswxz.com/2018/05/25/红黑树RBTREE/</id>
    <published>2018-05-24T16:00:00.000Z</published>
    <updated>2018-05-25T08:25:18.015Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一：简介"><a href="#一：简介" class="headerlink" title="一：简介"></a>一：简介</h3><p>红黑树从本质上来说就是一颗二叉查找树，但是在二叉树的基础上增加了着色相关的性质，使得红黑树可以保证相对平衡，从而保证红黑树的增删改查的时间复杂度最坏也能达到O(log N)。</p><h3 id="二：特点"><a href="#二：特点" class="headerlink" title="二：特点"></a>二：特点</h3><blockquote><ol><li>每个节点要么是黑的，要么是红的</li><li>根节点是黑的</li><li>叶节点是黑的</li><li>如果一个节点是红的，他的两个儿子节点都是黑的</li><li>对于任一节点而言，其到叶节点树尾端NIL指针的每一条路径都包含相同数目的黑节点</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一：简介&quot;&gt;&lt;a href=&quot;#一：简介&quot; class=&quot;headerlink&quot; title=&quot;一：简介&quot;&gt;&lt;/a&gt;一：简介&lt;/h3&gt;&lt;p&gt;红黑树从本质上来说就是一颗二叉查找树，但是在二叉树的基础上增加了着色相关的性质，使得红黑树可以保证相对平衡，从而保证红黑树的
      
    
    </summary>
    
      <category term="数据结构" scheme="http://blog.amoswxz.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="集合源码" scheme="http://blog.amoswxz.com/tags/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>List遇到的坑</title>
    <link href="http://blog.amoswxz.com/2018/05/22/List%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E4%B8%80%E4%BA%9B%E5%9D%91/"/>
    <id>http://blog.amoswxz.com/2018/05/22/List开发中遇到一些坑/</id>
    <published>2018-05-21T16:00:00.000Z</published>
    <updated>2018-05-24T07:12:16.694Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一：最近在开发过程中遇到一些问题，决定把遇到的这些问题记录下来，避免让别的小伙伴踩坑。"><a href="#一：最近在开发过程中遇到一些问题，决定把遇到的这些问题记录下来，避免让别的小伙伴踩坑。" class="headerlink" title="一：最近在开发过程中遇到一些问题，决定把遇到的这些问题记录下来，避免让别的小伙伴踩坑。"></a>一：最近在开发过程中遇到一些问题，决定把遇到的这些问题记录下来，避免让别的小伙伴踩坑。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = Lists.newArrayList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">      List&lt;Integer&gt; subList = list.subList(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">      list.retainAll(subList);</span><br><span class="line">      Iterator&lt;Integer&gt; iterator = subList.iterator();</span><br></pre></td></tr></table></figure><p>上面这段代码会出现ConcurrentModificationException。</p><p>1：先分析list.subList()这段代码 。需要特别注意17行代码，把原集合的modcont赋值给了新的集合。那么此时返回的subList的和list此时的modCount是相等的等于5。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查传入的下标位置</span></span><br><span class="line">    subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SubList(<span class="keyword">this</span>, <span class="number">0</span>, fromIndex, toIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> AbstractList&lt;E&gt; parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parentOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    SubList(AbstractList&lt;E&gt; parent,</span><br><span class="line">            <span class="keyword">int</span> offset, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex) &#123;</span><br><span class="line">        <span class="comment">//传入的this是ArrayList，所以此时parent是ArrayList</span></span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        <span class="comment">//截取开始的下标位置</span></span><br><span class="line">        <span class="keyword">this</span>.parentOffset = fromIndex;</span><br><span class="line">        <span class="comment">//截取开始的下标位置</span></span><br><span class="line">        <span class="keyword">this</span>.offset = offset + fromIndex;</span><br><span class="line">        <span class="comment">//截取的list的大小</span></span><br><span class="line">        <span class="keyword">this</span>.size = toIndex - fromIndex;</span><br><span class="line">        <span class="comment">//将原集合的modCount赋值给新集合</span></span><br><span class="line">        <span class="keyword">this</span>.modCount = ArrayList.<span class="keyword">this</span>.modCount;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>2：执行list.retainAll()代码的时候。list的modCount变成了8。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//判断传入的集合是否为空</span></span><br><span class="line">     Objects.requireNonNull(c);</span><br><span class="line">     <span class="keyword">return</span> batchRemove(c, <span class="keyword">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//获取原集合元素</span></span><br><span class="line">     <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;</span><br><span class="line">     <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">     <span class="comment">//定义一个标志位</span></span><br><span class="line">     <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//遍历原集合，如果包含这个元素，就把当前这个元素提前</span></span><br><span class="line">         <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">             <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">                 elementData[w++] = elementData[r];</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// Preserve behavioral compatibility with AbstractCollection,</span></span><br><span class="line">         <span class="comment">// even if c.contains() throws.</span></span><br><span class="line">         <span class="comment">//只有contains出现异常的时候才会走这个if</span></span><br><span class="line">         <span class="keyword">if</span> (r != size) &#123;</span><br><span class="line">             System.arraycopy(elementData, r,</span><br><span class="line">                              elementData, w,</span><br><span class="line">                              size - r);</span><br><span class="line">             w += size - r;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">             <span class="comment">// clear to let GC do its work</span></span><br><span class="line">             <span class="comment">//从w开始遍历，说明w以后的数据就不是我们想要的数据</span></span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</span><br><span class="line">                 elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">             <span class="comment">//遍历了多少次，modCount加多少次</span></span><br><span class="line">             modCount += size - w;</span><br><span class="line">             <span class="comment">//赋值给截取后的集合大小</span></span><br><span class="line">             size = w;</span><br><span class="line">             modified = <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> modified;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>3：执行subList.iterator()调用的方法是SubList类中的方法。重点关注</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">//ArrayList.this.modCount=8;this.modCount=5;所以会抛出异常</span></span><br><span class="line">         <span class="keyword">if</span> (ArrayList.<span class="keyword">this</span>.modCount != <span class="keyword">this</span>.modCount)</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>根据以上分析可以得出结论：</p><p>==在 subList 场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增加、删除均会产生ConcurrentModificationException 异常==</p><h3 id="二：Arrays-asList-以下代码会抛出UnsupportedOperationException"><a href="#二：Arrays-asList-以下代码会抛出UnsupportedOperationException" class="headerlink" title="二：Arrays.asList();以下代码会抛出UnsupportedOperationException"></a>二：Arrays.asList();以下代码会抛出UnsupportedOperationException</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">list.remove(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>1：以下是部分代码，Arrays.asList()创建对象是内部私有的ArrayList。并不是java.util.ArrayList。该ArrayList没有重写父类的 add/remove/clear等方法，所以调用上述方法会抛出 UnsupportedOperationException 异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span> include</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">RandomAccess</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2764017481108945198L</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> E[] a;</span><br><span class="line"></span><br><span class="line">        ArrayList(E[] array) &#123;</span><br><span class="line">            a = Objects.requireNonNull(array);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三：闲谈"><a href="#三：闲谈" class="headerlink" title="三：闲谈"></a>三：闲谈</h3><p> Amos在面试阿里的时候，阿里的一个面试官当初就问了Amos关于二个问题。</p><p>一：并发修改List会报什么错。当时一脸懵逼，只知道会报错，但是不知道报什么错==ConcurrentModificationException。==</p><p>二：遍历list的时候怎么样才能正确的删除数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误的写法，这里调用str.remove改变了modCount的值，所以报错ConcurrentModificationException</span></span><br><span class="line">    ArrayList&lt;Integer&gt; str = Lists.newArrayList();</span><br><span class="line">            str.add(<span class="number">1</span>);</span><br><span class="line">            str.add(<span class="number">2</span>);</span><br><span class="line">            str.add(<span class="number">3</span>);</span><br><span class="line">            <span class="comment">//此时iterator中的expactModCount=3</span></span><br><span class="line">            Iterator&lt;Integer&gt; iterator = str.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                Integer next = iterator.next();</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">//调用remove以后modCount=3+1 所以下一次调用iterator.next的时候报错</span></span><br><span class="line">                    str.remove(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//错误的写法 foreach循环底层用的还是iterator</span></span><br><span class="line"> ArrayList&lt;Integer&gt; str = Lists.newArrayList();</span><br><span class="line">        str.add(<span class="number">1</span>);</span><br><span class="line">        str.add(<span class="number">2</span>);</span><br><span class="line">        str.add(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer s : str) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="number">1</span>) &#123;</span><br><span class="line">                str.remove(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正确写法一</span></span><br><span class="line">    ArrayList&lt;Integer&gt; str = Lists.newArrayList();</span><br><span class="line">            str.add(<span class="number">1</span>);</span><br><span class="line">            str.add(<span class="number">2</span>);</span><br><span class="line">            str.add(<span class="number">3</span>);</span><br><span class="line">            <span class="comment">//此时iterator中的expactModCount=3</span></span><br><span class="line">            Iterator&lt;Integer&gt; iterator = str.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                Integer next = iterator.next();</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="comment">//调用remove以后modCount=3+1 所以下一次调用iterator.next的时候报错</span></span><br><span class="line">          <span class="comment">//这里使用iterator调用 这里改变了cursor下标，改变了expectModCount的值，所以不出现ConcurrentModificationException</span></span><br><span class="line">                   iterator.remove(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//正确写法二 这里使用倒序删除，取巧。避免了漏掉。也可以使用正序删除，改变下标</span></span><br><span class="line">   ArrayList&lt;Integer&gt; str = Lists.newArrayList();</span><br><span class="line">            str.add(<span class="number">1</span>);</span><br><span class="line">            str.add(<span class="number">2</span>);</span><br><span class="line">            str.add(<span class="number">3</span>);</span><br><span class="line">            str.add(<span class="number">5</span>);</span><br><span class="line">            str.add(<span class="number">6</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = intList.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  </span><br><span class="line">           Integer value = intList.get(i);  </span><br><span class="line">           <span class="keyword">if</span>(value == <span class="number">3</span> || value == <span class="number">5</span>) &#123;  </span><br><span class="line">              intList.remove(i);  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一：最近在开发过程中遇到一些问题，决定把遇到的这些问题记录下来，避免让别的小伙伴踩坑。&quot;&gt;&lt;a href=&quot;#一：最近在开发过程中遇到一些问题，决定把遇到的这些问题记录下来，避免让别的小伙伴踩坑。&quot; class=&quot;headerlink&quot; title=&quot;一：最近在开
      
    
    </summary>
    
      <category term="集合源码" scheme="http://blog.amoswxz.com/categories/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="集合源码" scheme="http://blog.amoswxz.com/tags/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Iterator和Iterable</title>
    <link href="http://blog.amoswxz.com/2018/05/21/Iterator%E5%92%8CIterable/"/>
    <id>http://blog.amoswxz.com/2018/05/21/Iterator和Iterable/</id>
    <published>2018-05-20T16:00:00.000Z</published>
    <updated>2018-05-21T06:49:12.965Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一：-Iterator和Iterable都是接口-Iterable接口中定义Iterator"><a href="#一：-Iterator和Iterable都是接口-Iterable接口中定义Iterator" class="headerlink" title="一：  Iterator和Iterable都是接口,Iterable接口中定义Iterator"></a>一：  Iterator和Iterable都是接口,Iterable接口中定义Iterator</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否下一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"remove"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">while</span> (hasNext())</span><br><span class="line">            action.accept(next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.Spliterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Spliterators;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an iterator over elements of type &#123;<span class="doctag">@code</span> T&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an Iterator.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">            action.accept(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">default</span> Spliterator&lt;T&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二：为什么集合类都是实现Iterable接口而不是实现Iterator"><a href="#二：为什么集合类都是实现Iterable接口而不是实现Iterator" class="headerlink" title="二：为什么集合类都是实现Iterable接口而不是实现Iterator"></a>二：为什么集合类都是实现Iterable接口而不是实现Iterator</h3><p>​    1：如果实现Iterator接口，势必导致集合对象中包含当前迭代位置的数据(指针)。 当集合在不同方法间被传递时，由于当前迭代位置不可预置，那么next()方法的结果会变成不可预知。 除非再为Iterator接口添加一个reset()方法，用来重置当前迭代位置。 但即时这样，Collection也只能<strong>同时存在一个当前迭代位置</strong>。 而Iterable则不然，每次调用都会返回一个从头开始计数的迭代器（新的迭代器）。 多个迭代器是互不干扰的。这句话的意思就是。有一个成员变量集合，两个方法使用这个集合，同时遍历的时候，会导致next()方法的结果未知。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一：-Iterator和Iterable都是接口-Iterable接口中定义Iterator&quot;&gt;&lt;a href=&quot;#一：-Iterator和Iterable都是接口-Iterable接口中定义Iterator&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="集合源码" scheme="http://blog.amoswxz.com/categories/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="集合源码" scheme="http://blog.amoswxz.com/tags/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>集合源码篇（HashMap）</title>
    <link href="http://blog.amoswxz.com/2018/05/21/HashMap/"/>
    <id>http://blog.amoswxz.com/2018/05/21/HashMap/</id>
    <published>2018-05-20T16:00:00.000Z</published>
    <updated>2018-05-30T03:28:29.932Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一：HashMap简介"><a href="#一：HashMap简介" class="headerlink" title="一：HashMap简介"></a>一：HashMap简介</h3><p>  1： HashMap存储结构</p><p><img src="image-20180521154332523.png" alt="image-20180521154332523"></p><p><img src="image-20180521160307137.png" alt="image-20180521160307137"></p><p>2：HashMap：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</p><h3 id="二：源码解析"><a href="#二：源码解析" class="headerlink" title="二：源码解析"></a>二：源码解析</h3><p>1：成员变量 bin(是hashmap专用术语，约定桶后面存放的每一个数据称为<strong>bin</strong> )</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 默认的初始容量，必须是2的幂</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 最大的容量。1073741824 必须是2的幂</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 没有指定的时候默认加载因子 默认的负载因子0.75是对空间和时间效率的一个平衡选择</span></span><br><span class="line"><span class="comment">   * 如果内存空间很多而又对时间效率要求很高，可以降低负载因子Loadfactor的值；</span></span><br><span class="line"><span class="comment">   * 如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * bin转为红黑树判断条件之一 bin数量大于8</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *由树转换成链表的阈值UNTREEIFY_THRESHOLD</span></span><br><span class="line"><span class="comment">   *当执行resize操作时，当桶中bin的数量少于UNTREEIFY_THRESHOLD时使用链表来代替树。默认值是6 </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 如果bin中的数量大于TREEIFY_THRESHOLD，但是capacity小于MIN_TREEIFY_CAPACITY，依然使用链表存储。此时会进行resize操作;如果capacity大于MIN_TREEIFY_CAPACITY进行树化</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *存放KV数据的数组。第一次使用的时候被初始化，根据需要可以重新resize。分配的长度总是2的幂。 </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 当被调用entrySet时被赋值。通过keySet()方法可以得到map key的集合，通过values方法可以得到map       * value的集合。 </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * map的大小</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 结构修改的次数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 填充因子</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><h3 id="3：构造函数"><a href="#3：构造函数" class="headerlink" title="3：构造函数"></a>3：构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> initialCapacity 初始容量</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> loadFactor 填充因子</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//容量小于0抛出illega异常</span></span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       <span class="comment">//如果初始容量大于1&lt;&lt;30 那么容量大小就等于1&lt;&lt;30</span></span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">       <span class="comment">//如果加载因子小于等于0或者不是float类型</span></span><br><span class="line">       <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                              loadFactor);</span><br><span class="line">       <span class="comment">//赋值填充因子</span></span><br><span class="line">       <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">       <span class="comment">//临界值 刚开始以为这样写是一个Bug，</span></span><br><span class="line">       <span class="comment">//觉得应该这样写this.threshold = tableSizeFor(initialCapacity) * this.loadFactor;</span></span><br><span class="line"><span class="comment">//此处带着疑问去看put方法，就会明白此处为啥这么设计。这里是懒加载。并没有new的时候直接加载</span></span><br><span class="line">       <span class="comment">//找到大于等于initialCapacity的最小的2的幂</span></span><br><span class="line">       <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> initialCapacity 初始容量</span></span><br><span class="line"><span class="comment">    * 使用默认的加载因子</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 默认容量16，默认加载因子0.75</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 传入一个map,使用默认加载因子</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">       <span class="comment">//这个方法下文putAll的时候会详细介绍</span></span><br><span class="line">       putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="4：常用方法介绍"><a href="#4：常用方法介绍" class="headerlink" title="4：常用方法介绍"></a>4：常用方法介绍</h3><p>4.1：put()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">*这里就是低16位和高16位异或。为什么要这么做呢？...与hashTable计算下标有关。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> h;</span><br><span class="line">       <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key hash以后的值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> onlyIfAbsent true:不改变存在的值;false:改变存在的值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 返回老的值或者空</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">       <span class="comment">//判断节点数组是否为null,是null进行扩容 ;不等于null,把节点长度赋值给n,节点长度为0扩容</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">           <span class="comment">//进行扩容操作，并把扩容后的长度赋值给n</span></span><br><span class="line">           n = (tab = resize()).length;</span><br><span class="line">       <span class="comment">// (tab.length-1)&amp;hash 得到index 。注意，同一个元素在扩容前后可能得到的index不一样</span></span><br><span class="line">       <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">           <span class="comment">//如果等于null，直接newNode，放入tab;不等于null,p=当前下标得到的第一个bin</span></span><br><span class="line">           tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           Node&lt;K,V&gt; e; K k;</span><br><span class="line">           <span class="comment">//判断第一个节点是否等于当前元素，如果等于赋值给e。</span></span><br><span class="line">          <span class="keyword">if</span> (p.hash == hash &amp;&amp;((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               e = p;</span><br><span class="line">           <span class="comment">//判断p是否是treeNode，如果是红黑树，则添加数据。红黑树的crud有文章介绍</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">               e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//循环查找元素</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                   <span class="comment">//获取p的下一个bin</span></span><br><span class="line">                   <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">//构建一个新的节点，把地址赋值给上个记得点的next指针域</span></span><br><span class="line">                       p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                       <span class="comment">//判断bin数量是否大于8。这里减1因为binCount是从0开始的</span></span><br><span class="line">                       <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                           <span class="comment">//转为红黑树。</span></span><br><span class="line">                           <span class="comment">//如果容量小于MIN_TREEIFY_CAPACITY，不会进行树化，会进行扩容</span></span><br><span class="line">                           treeifyBin(tab, hash);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//判断元素是否等于当前元素。和上面同理</span></span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   p = e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//e不等于空，说明之前已经存在这个key</span></span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">               <span class="comment">//获取老的值</span></span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               <span class="comment">//onlyIfAbsent=fals 或者oldValue=null 改变存在的值。返回老的值</span></span><br><span class="line">               <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                   e.value = value;</span><br><span class="line">               <span class="comment">//这个方法是为了LinkedHashMap服务的</span></span><br><span class="line">               afterNodeAccess(e);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//改变了结构，modCount加1</span></span><br><span class="line">       ++modCount;</span><br><span class="line">       <span class="comment">//判断size+1 是否大于临界值，大于扩容</span></span><br><span class="line">       <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">           resize();</span><br><span class="line">       <span class="comment">//这个方法是为了LinkedHashMap服务的</span></span><br><span class="line">       afterNodeInsertion(evict);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>4.2：resize()方法，借用了网上一张图片</p><p><img src="/Users/mujourney/Amos-Blog/source/_posts/image-20180529210946248.png" alt="image-20180529210946248"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 初始化table,或者table的大小扩大两倍。如果是table空，根据tableSizeFor方法计算出threshold的值，然后赋值给capacity，然后重新计算threshold=capacit*loadFactor。如果table不为空。根据2的幂来扩容，原来bin的元素要么在原来的位置或者从原来的位置移动到（原索引+oldCap）。扩容以后看新增hash值的bit位是1,index=（原索引+oldCap）,否则就是原来的index位置</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">     <span class="comment">//当前table赋值给oldTab</span></span><br><span class="line">     Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">     <span class="comment">//获取老的table长度</span></span><br><span class="line">     <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">     <span class="comment">//当前的threshold赋值给oldThr</span></span><br><span class="line">     <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">     <span class="comment">//定义新的容量，新的临界值</span></span><br><span class="line">     <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">     <span class="comment">//如果老的容量大于0</span></span><br><span class="line">     <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">//老的容量大于最大容量</span></span><br><span class="line">         <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">             <span class="comment">//临界值等于Integer.MAX_VALUE</span></span><br><span class="line">             threshold = Integer.MAX_VALUE;</span><br><span class="line">             <span class="keyword">return</span> oldTab;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//oldCap扩大2倍赋值给newCap,比较newCap是否小于最大容量 并且oldCap大于等于默认容量</span></span><br><span class="line">         <span class="comment">//如果满足，oldThr扩大两倍赋值给newThr</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                  oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">             newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//如果oldThr大于0，说明初始化map的传入了初始容量</span></span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">         <span class="comment">//oldThr赋值给newCap</span></span><br><span class="line">         newCap = oldThr;</span><br><span class="line">     <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">         <span class="comment">//进入此处，说明new HashMap的时候没有指定容量。</span></span><br><span class="line">         <span class="comment">//赋值默认容量，临界值等于默认容量*默认加载因子</span></span><br><span class="line">         newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">         newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//如果newThr等于0，说明oldThr大于0；</span></span><br><span class="line">     <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">//新的容量*加载因子得到新的临界值</span></span><br><span class="line">         <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">         <span class="comment">//赋值newThr</span></span><br><span class="line">         newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                   (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//临界值赋值给threshold</span></span><br><span class="line">     threshold = newThr;</span><br><span class="line">     <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">     <span class="comment">//定义新的table数组，指定长度为newCap</span></span><br><span class="line">         Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">     <span class="comment">//newTab赋值给table</span></span><br><span class="line">     table = newTab;</span><br><span class="line">     <span class="comment">//判断oldTab是否等于null</span></span><br><span class="line">     <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">//循环oldCap，把老的元素重新放入newCap</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">             <span class="comment">//定义e元素</span></span><br><span class="line">             Node&lt;K,V&gt; e;</span><br><span class="line">             <span class="comment">//获取j位置的索引赋值给e，判断oldTab是否等于空</span></span><br><span class="line">             <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="comment">//把下标为j的元素置为空</span></span><br><span class="line">                 oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                 <span class="comment">//判断e后面是否还有元素</span></span><br><span class="line">                 <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                     <span class="comment">//把e放入newTab 新的index处</span></span><br><span class="line">                     newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                 <span class="comment">//判断e是否是红黑树，此处不细讲。后面会讲</span></span><br><span class="line">                 <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                     ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                 <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                     <span class="comment">//以下代码作用保护排序和元素移动。</span></span><br><span class="line">               <span class="comment">//元素移动：把oldTab中的元素挂到newTab中。这里需要注意的是，元素的位置可能不变，     也有可能变为(原索引+oldCap)</span></span><br><span class="line">                     <span class="comment">//定义节点元素。lohead代表index不变的元素</span></span><br><span class="line">                     Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                     Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                     Node&lt;K,V&gt; next;</span><br><span class="line">                     <span class="keyword">do</span> &#123;</span><br><span class="line">                         <span class="comment">//e的下一个元素赋值给next</span></span><br><span class="line">                         next = e.next;</span><br><span class="line">             <span class="comment">//判断bin中元素的index是否变化，如果==0说明index没变。</span></span><br><span class="line">                         <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                             <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                 loHead = e;</span><br><span class="line">                             <span class="keyword">else</span></span><br><span class="line">                                 loTail.next = e;</span><br><span class="line">                             loTail = e;</span><br><span class="line">                         &#125;</span><br><span class="line">                       <span class="comment">//不等于0说明index=index+oldCap</span></span><br><span class="line">                         <span class="keyword">else</span> &#123;</span><br><span class="line">                             <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                 hiHead = e;</span><br><span class="line">                             <span class="keyword">else</span></span><br><span class="line">                                 hiTail.next = e;</span><br><span class="line">                             hiTail = e;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                     <span class="comment">//将节点元素放入数组中</span></span><br><span class="line">                     <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                         newTab[j] = loHead;</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="comment">//将节点元素放入j+oldCap</span></span><br><span class="line">                     <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                         newTab[j + oldCap] = hiHead;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> newTab;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>4.3：get()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 传入key</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     Node&lt;K,V&gt; e;</span><br><span class="line">     <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> 对key进行hash</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//定义Node数组；定义一个节点first,e;定义n,定义一个K类型的k</span></span><br><span class="line">     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">     <span class="comment">//判断，如果table不等于null,table的长度大于0,根据计算出来的index获取table元素不等于null</span></span><br><span class="line">     <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">         (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">//这里总是检查第一个元素，我也不知道为啥这么检查。有知道的朋友可以分享一下</span></span><br><span class="line">         <span class="comment">//判断第一个元素的hash和传入key的hash是否相等并且判断传入的key等于first的key</span></span><br><span class="line">         <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">             ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">             <span class="comment">//返回第一个节点元素</span></span><br><span class="line">             <span class="keyword">return</span> first;</span><br><span class="line">         <span class="comment">//判断first节点下是否还挂着其它节点</span></span><br><span class="line">         <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">//判断是否树化</span></span><br><span class="line">             <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                 <span class="comment">//从红黑树中查找</span></span><br><span class="line">                 <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">             <span class="keyword">do</span> &#123;</span><br><span class="line">                 <span class="comment">//循环查找，没有找到返回null</span></span><br><span class="line">                 <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                     ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                     <span class="keyword">return</span> e;</span><br><span class="line">             &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>4.4：putAll()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *拷贝传入的元素到map</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">       putMapEntries(m, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m the map</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> evict 是false代表是构造方法的时候调用这个，如果是true代表是其它方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//获取map的大小</span></span><br><span class="line">       <span class="keyword">int</span> s = m.size();</span><br><span class="line">       <span class="comment">//如果size大于0</span></span><br><span class="line">       <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//判断table是否为null</span></span><br><span class="line">           <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">               <span class="comment">//使用s/loadFactor+1.0 其实是为了获得table的容量</span></span><br><span class="line">               <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">               <span class="comment">//比较容量是否超过最大值</span></span><br><span class="line">               <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                        (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">               <span class="comment">//扩大临界值</span></span><br><span class="line">               <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                   threshold = tableSizeFor(t);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//扩容判断</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">               resize();</span><br><span class="line">           <span class="comment">//循环添加</span></span><br><span class="line">           <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">               K key = e.getKey();</span><br><span class="line">               V value = e.getValue();</span><br><span class="line">               putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>4.5：remove()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> hash hash以后的值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value 如果matchValue是true,才使用value,其它忽略</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> matchValue 如果true必须value，key相等才能删除 only remove if value is equal</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> movable 如果false删除的时候不移动节点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//定义一个tab,定义一个Node </span></span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">      <span class="comment">//table不等于null并且table长度大于0，根据index获取table元素不等于null</span></span><br><span class="line">      <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">          (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//定义变量</span></span><br><span class="line">          Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">          <span class="comment">//判断第一个节点是否key是否相等，如果相等</span></span><br><span class="line">          <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">              ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">              <span class="comment">//赋值node</span></span><br><span class="line">              node = p;</span><br><span class="line">          <span class="comment">//判断下一个节点元素是否</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">//判断p是否是红黑树</span></span><br><span class="line">              <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                  node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">//循环bin判断key是否存在</span></span><br><span class="line">                  <span class="keyword">do</span> &#123;</span><br><span class="line">                      <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                          ((k = e.key) == key ||</span><br><span class="line">                           (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                          node = e;</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                      p = e;</span><br><span class="line">                  &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//node不等于null，说明根据这个key找到了这个元素。判断value是否相等</span></span><br><span class="line">          <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                               (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">              <span class="comment">//判断是否是红黑树</span></span><br><span class="line">              <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                  ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">              <span class="comment">//判断node是否是第一个元素。如果是获取node的下一个元素赋值给tab[index]</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                  tab[index] = node.next;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">               <span class="comment">//不是第一个元素。从p元素口面删除node元素</span></span><br><span class="line">                  p.next = node.next;</span><br><span class="line">              ++modCount;</span><br><span class="line">              --size;</span><br><span class="line">              afterNodeRemoval(node);</span><br><span class="line">              <span class="keyword">return</span> node;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>4.6：keySet()和Values()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 返回此映射中包含的键的map视图</span></span><br><span class="line"><span class="comment">     * 解惑：最开始在看这段代码的时候并没有看懂。此处直接返回了一个包含key的Set集合，但是又没有对map的key进行处理，所以一直在纠结这里是怎么处理的。最后在同事的指点下，幡然大悟。这里只是返回了一个包含map的视图，对这个集合进行遍历的时候会调用iterator方法。iteraotr方法会调用new KeyIterator()；KeyIterator这个类继承了hashIterator。遍历set集合的时候会调用next方法。next方法会调用HashIterator的NextNode方法。下面对nextNode方法做了介绍</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Set&lt;K&gt; ks = keySet;</span><br><span class="line">      <span class="keyword">if</span> (ks == <span class="keyword">null</span>) &#123;</span><br><span class="line">          ks = <span class="keyword">new</span> KeySet();</span><br><span class="line">          keySet = ks;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ks;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator(); &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> containsKey(o); &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;K&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> KeySpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> K&gt; action)</span> </span>&#123;</span><br><span class="line">          Node&lt;K,V&gt;[] tab;</span><br><span class="line">          <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">          <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">int</span> mc = modCount;</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                  <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                      action.accept(e.key);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">      <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().key; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">      Node&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></span><br><span class="line">      Node&lt;K,V&gt; current;     <span class="comment">// current entry</span></span><br><span class="line">      <span class="keyword">int</span> expectedModCount;  <span class="comment">// for fast-fail</span></span><br><span class="line">      <span class="keyword">int</span> index;             <span class="comment">// current slot</span></span><br><span class="line"><span class="comment">//调用iterator的方法的时候会初始化HashIterator</span></span><br><span class="line">      HashIterator() &#123;</span><br><span class="line">          <span class="comment">//把map中的modCount赋值给expectedModCount</span></span><br><span class="line">          expectedModCount = modCount;</span><br><span class="line">          <span class="comment">//table赋值给t</span></span><br><span class="line">          Node&lt;K,V&gt;[] t = table;</span><br><span class="line">          current = next = <span class="keyword">null</span>;</span><br><span class="line">          index = <span class="number">0</span>;</span><br><span class="line">          <span class="comment">//找到一个bin元素不为空就返回</span></span><br><span class="line">          <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">              <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//nextNode方法 此处就是循环查找next元素</span></span><br><span class="line">      <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">//定义t</span></span><br><span class="line">          Node&lt;K,V&gt;[] t;</span><br><span class="line">          <span class="comment">//把next元素赋值给e</span></span><br><span class="line">          Node&lt;K,V&gt; e = next;</span><br><span class="line">          <span class="comment">//判断线性结构的修改</span></span><br><span class="line">          <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">          <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">          <span class="comment">//如果bin上还有节点直接返回下一个节点。如果没有循环则循环table查找下一个index的node元素</span></span><br><span class="line">          <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> e;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          Node&lt;K,V&gt; p = current;</span><br><span class="line">          <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">          <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">          current = <span class="keyword">null</span>;</span><br><span class="line">          K key = p.key;</span><br><span class="line">          removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">          expectedModCount = modCount;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>haspMap其它方法就不一一介绍。下一篇文章会对hashMap进行总结以及面试会被问的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一：HashMap简介&quot;&gt;&lt;a href=&quot;#一：HashMap简介&quot; class=&quot;headerlink&quot; title=&quot;一：HashMap简介&quot;&gt;&lt;/a&gt;一：HashMap简介&lt;/h3&gt;&lt;p&gt;  1： HashMap存储结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;
      
    
    </summary>
    
      <category term="集合源码" scheme="http://blog.amoswxz.com/categories/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="集合源码" scheme="http://blog.amoswxz.com/tags/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>集合源码篇（LinkedList）</title>
    <link href="http://blog.amoswxz.com/2018/05/04/LinkedList/"/>
    <id>http://blog.amoswxz.com/2018/05/04/LinkedList/</id>
    <published>2018-05-03T16:00:00.000Z</published>
    <updated>2018-05-08T15:16:46.027Z</updated>
    
    <content type="html"><![CDATA[<p>###LinkedList简介</p><p>LinkedList是基于链表的，是线程不安全的，允许为null。增删只需要修改节点指针，所以增删时间效率很高，不需要扩容，也不需要预留空间。缺点就是随机访问的时候，效率很低。</p><h3 id="LinkedList类关系图"><a href="#LinkedList类关系图" class="headerlink" title="## LinkedList类关系图"></a>## LinkedList类关系图</h3><p><img src="image-20180504172137806.png" alt="image-20180504172137806"></p><p>从图可以看出LinkedList实现了deque。可以作为一个双端队列来使用。不支持随机访问</p><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 头结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指向最后一个节点的引用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空的构造方法.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *有参构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Node的结构.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;</span><br><span class="line">        <span class="comment">//下个节点的指针域</span></span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        <span class="comment">//上个节点的指针域</span></span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = element;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * LinkedList默认采用的是尾插法.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//尾节点的引用赋值给零食变量l</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="comment">//构建新节点</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//新节点赋值给尾节点引用</span></span><br><span class="line">        last = newNode;</span><br><span class="line">        <span class="comment">//尾节点引用为空，说明第一次添加节点</span></span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">           <span class="comment">//尾节点的next域指针指向新节点</span></span><br><span class="line">            l.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 头插法.插入第一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将头节点赋值临时变量f</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="comment">//构建新节点</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">        <span class="comment">//将新节点赋值给头结点</span></span><br><span class="line">        first = newNode;</span><br><span class="line">        <span class="comment">//如果头结点为空，新节点就是头结点</span></span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">            last = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//新节点赋值给上一个节点的前指针</span></span><br><span class="line">            f.prev = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断元素的位置 从头开始查找</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//定义下标</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//判断o是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//从头节点开始查找</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//从尾节点开始查找</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增元素。index表示从下标index开始新增。c表示集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断index是否大于等于0并且小于等于size</span></span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line"><span class="comment">//集合转数组</span></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="comment">//数组长度</span></span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        <span class="comment">//如果等于0说明传入的是一个空集合</span></span><br><span class="line">        <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Node&lt;E&gt; pred, succ;</span><br><span class="line">       <span class="comment">//从尾节点开始添加</span></span><br><span class="line">        <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">            succ = <span class="keyword">null</span>;</span><br><span class="line">            pred = last;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//这里是一个二分查找。succ是index位置的节点</span></span><br><span class="line">            succ = node(index);</span><br><span class="line">            <span class="comment">//获取index节点的上一个指针</span></span><br><span class="line">            pred = succ.prev;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//循环添加元素，添加完成以后pred是最后一个节点</span></span><br><span class="line">        <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</span><br><span class="line">            Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                first = newNode;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pred.next = newNode;</span><br><span class="line">            pred = newNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//最后一个节点引用赋值</span></span><br><span class="line">            last = pred;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果不是尾插，就把插入完成后的节点跟之前的节点拼接</span></span><br><span class="line">        <span class="comment">//现在pred是最后一个节点。把succ赋值给pred节点的next</span></span><br><span class="line">            pred.next = succ;</span><br><span class="line">            succ.prev = pred;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size += numNew;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###LinkedList简介&lt;/p&gt;
&lt;p&gt;LinkedList是基于链表的，是线程不安全的，允许为null。增删只需要修改节点指针，所以增删时间效率很高，不需要扩容，也不需要预留空间。缺点就是随机访问的时候，效率很低。&lt;/p&gt;
&lt;h3 id=&quot;LinkedList类关系
      
    
    </summary>
    
      <category term="集合源码" scheme="http://blog.amoswxz.com/categories/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="集合源码" scheme="http://blog.amoswxz.com/tags/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>集合源码篇（ArrayList）</title>
    <link href="http://blog.amoswxz.com/2018/04/18/ArrayList/"/>
    <id>http://blog.amoswxz.com/2018/04/18/ArrayList/</id>
    <published>2018-04-17T16:00:00.000Z</published>
    <updated>2018-05-22T17:24:17.074Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ArrayList简介"><a href="#ArrayList简介" class="headerlink" title="ArrayList简介"></a>ArrayList简介</h3><p>ArrayList是基于数组实现的，是一个动态数组。容量可以自动增加动态增长内存。</p><p>ArrayList是线程不安全的，只能在单线程环境下使用。多线程环境下使用juc下面的CopyOnWriteArrayList（后续会介绍）</p><h3 id="ArrayList类关系图"><a href="#ArrayList类关系图" class="headerlink" title="ArrayList类关系图"></a>ArrayList类关系图</h3><p><img src="ArrayList.png" alt="ArrayList"></p><p>从该图可以看到，ArrayList继承AbstractList类，AbstractList类实现List接口；ArrayList实现了List接口。有人就会问，为什么ArrayList既要继承AbstractList又实现了List接口呢。这是因为java集合框架用到了很多适配器模式，用AbstractList去实现List接口，这样ArrayList继承AbstractList只需要重写自己需要的方法即可，不用实现接口中的所有方法。实现了randomAccess接口，RandomAccess 是一个空的接口，它用来标识某个类是否支持 <strong>随机访问</strong>（随机访问，相对比“按顺序访问”）。一个支持随机访问的类明显可以使用更加高效的算法。</p><h5 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">import</span> java.util.function.UnaryOperator;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**很多人往往忽略了类上面的注释，其实这个注释才是最重要的。上面注释大概介绍了几点</span></span><br><span class="line"><span class="comment">         *1：ArrayList是List接口的大小可变数组实现的，实现了List中接口中的所有方法。允许元素为null。</span></span><br><span class="line"><span class="comment">         *2：时间复杂度：size()，isEmpty()，get()，set()，iterator()，listIterator()，这些操作时间复杂度是 o(1)。</span></span><br><span class="line"><span class="comment">         因为是根据数组下标实现的。可以根据索引直接定位到元素位置。add()，remove()方法的时间复杂度是o(n)。因为添加删除元素需要移动元素位置。</span></span><br><span class="line"><span class="comment">         *3：ArrayList容量可以自动增长</span></span><br><span class="line"><span class="comment">         *4：ArrayList不是同步的，并发修改会返回fail-fast。会抛出ConcurrentModificationException**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Default initial capacity.</span></span><br><span class="line"><span class="comment">     * 默认初始化容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定ArrayList容量为0时，返回该空数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用无参构造的时候返回该对象。与EMPTY_ELEMENTDATA的区别在于</span></span><br><span class="line"><span class="comment">     * 指定容量大小为0返回EMPTY_ELEMENTDATA。默认返回DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存到ArrayList中元素，ArrayList的容量就是数组大小</span></span><br><span class="line"><span class="comment"> * 第一次添加元素到ArrayList，该数组扩容为默认的大小DEFAULT_CAPACITY</span></span><br><span class="line"><span class="comment">     * transient 被标记表示不可序列化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The size of the ArrayList (the number of elements it contains).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     * ArrayList的大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ArrayList提供了三个构造函数"><a href="#ArrayList提供了三个构造函数" class="headerlink" title="ArrayList提供了三个构造函数"></a>ArrayList提供了三个构造函数</h5><p><img src="image-201804190003174.png" alt="image-201804190003174"></p><p>初始化一个空数组：注意这里并不是初始化容量为10的数组</p><p>初始化一个collection 元素列表。将collection转为数组，判断数组大小是否为0，如果是0返回EMPTY_ELEMENTDATA。否则返回的是重新创建的数组并且数组大小是传入的collection大小.</p><p><img src="image-201804190007478.png" alt="image-201804190007478"></p><p>注意事项：</p><p><a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6260652" target="_blank" rel="noopener">c.toArray might (incorrectly) not return Object[] (see 6260652) 这里其实是一个JDK1.8的bug</a> ；这个bug的意思就是 Arrays.asList(x).toArray().getClass() should be Object[].class 但是返回的是class [Ljava.lang.String；jdk9已经修复。</p><p>Arrays.copy方法调用的是</p><p><img src="image-201804192120011.png" alt="image-201804192120011"></p><p><a href="https://stackoverflow.com/questions/29494800/do-not-understand-the-source-code-of-arrays-copyof" target="_blank" rel="noopener">这里为什么要判断((Object)newType == (Object)Object[].class)  如果是Object直接静态创建，在Array.newInstance中创建新实例的原因很可能是性能选择，如果程序总是需要创建新实例，那么它将比直接初始化一个通用对象数组和复制东西更加昂贵。Stack Overflow 上面有对该代码的解释</a></p><p>ArrayList中方法介绍</p><p>trimToSize()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 优化数组大小，只保留存储添加进去元素的空间</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     modCount++;</span><br><span class="line">     <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">         elementData = (size == <span class="number">0</span>)</span><br><span class="line">           ? EMPTY_ELEMENTDATA</span><br><span class="line">           : Arrays.copyOf(elementData, size);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>add()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//当前size+1</span></span><br><span class="line">      ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">      elementData[size++] = e;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断当前元素是否等于空 第一次执行add的时候执行才会是true</span></span><br><span class="line">      <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">          <span class="comment">//当前容量和默认容量10比较，取大的值</span></span><br><span class="line">          minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">      &#125;</span><br><span class="line">      ensureExplicitCapacity(minCapacity);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//结构修改次数；该变量主要是用来实现fail-fast机制的    </span></span><br><span class="line">      modCount++;</span><br><span class="line">      <span class="comment">// overflow-conscious code</span></span><br><span class="line">      <span class="comment">//当前size+1大于数组容量进行扩容</span></span><br><span class="line">      <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">          grow(minCapacity);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 增加容量以确保它至少能容纳。</span></span><br><span class="line"><span class="comment">* 最小容量参数指定的元素个数。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// overflow-conscious code</span></span><br><span class="line">      <span class="comment">// 获取老的数组大小</span></span><br><span class="line">      <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">      <span class="comment">//新的数组大小=1.5倍老的数组大小</span></span><br><span class="line">      <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 第一次扩容的时候才会用到，即第一次add的时候</span></span><br><span class="line">      <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">          newCapacity = minCapacity;</span><br><span class="line">      <span class="comment">/**为什么要减去8呢？</span></span><br><span class="line"><span class="comment">       *因为某些JVM会在数组中保留一些头字，尝试分配这个最大存储容量，可能会导致array容量大于JVM的限制，最终导致OutOfMemoryError。</span></span><br><span class="line"><span class="comment">       *判断数组容量是否达到Integer.MAX_VALUE - 8,达到就返回Integer.MAX_VALUE - 8**/</span></span><br><span class="line">      <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">          newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">      <span class="comment">//数组扩容</span></span><br><span class="line">      elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">      <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">          Integer.MAX_VALUE :</span><br><span class="line">          MAX_ARRAY_SIZE;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>iterator()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">      <span class="comment">//访问下一个元素的索引</span></span><br><span class="line">      <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">      <span class="comment">//访问上一个元素的索引</span></span><br><span class="line">      <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">      <span class="comment">//ArrayList修改次数</span></span><br><span class="line">      <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//判断是否有下一个元素</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> cursor != size;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//获取下一个元素</span></span><br><span class="line">      <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">      <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">//检查集合内容是否被修改</span></span><br><span class="line">          checkForComodification();</span><br><span class="line">          <span class="keyword">int</span> i = cursor;</span><br><span class="line">          <span class="comment">//下一个元素的下标等于size说明没有元素</span></span><br><span class="line">          <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">          <span class="comment">//获取ArrayList中数据</span></span><br><span class="line">          Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">          <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">          cursor = i + <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">          checkForComodification();</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">//删除元素</span></span><br><span class="line">              ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">              <span class="comment">//删除元素的下标给下一个元素</span></span><br><span class="line">              cursor = lastRet;</span><br><span class="line">              lastRet = -<span class="number">1</span>;</span><br><span class="line">              expectedModCount = modCount;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; consumer)</span> </span>&#123;</span><br><span class="line">          Objects.requireNonNull(consumer);</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">int</span> size = ArrayList.<span class="keyword">this</span>.size;</span><br><span class="line">          <span class="keyword">int</span> i = cursor;</span><br><span class="line">          <span class="keyword">if</span> (i &gt;= size) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">final</span> Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">          <span class="keyword">if</span> (i &gt;= elementData.length) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="line">              consumer.accept((E) elementData[i++]);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// update once at end of iteration to reduce heap write traffic</span></span><br><span class="line">          cursor = i;</span><br><span class="line">          lastRet = i - <span class="number">1</span>;</span><br><span class="line">          checkForComodification();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ArrayList简介&quot;&gt;&lt;a href=&quot;#ArrayList简介&quot; class=&quot;headerlink&quot; title=&quot;ArrayList简介&quot;&gt;&lt;/a&gt;ArrayList简介&lt;/h3&gt;&lt;p&gt;ArrayList是基于数组实现的，是一个动态数组。容量可以自动增加
      
    
    </summary>
    
      <category term="集合源码" scheme="http://blog.amoswxz.com/categories/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="集合源码" scheme="http://blog.amoswxz.com/tags/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>数据结构简介（Queue）</title>
    <link href="http://blog.amoswxz.com/2018/04/17/Queue/"/>
    <id>http://blog.amoswxz.com/2018/04/17/Queue/</id>
    <published>2018-04-16T16:00:00.000Z</published>
    <updated>2018-05-13T08:52:15.717Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1：Queue简介"><a href="#1：Queue简介" class="headerlink" title="1：Queue简介"></a>1：Queue简介</h3><p>1.1：队列先进先出（First Input First Output），队列是一种特殊的线性表，特殊之处在于只允许从表的前端删除，后端插入。进行插入操作的称为队尾。进行删除操作的叫队头。</p><p><img src="image-20180508005517463.png" alt="image-20180508005517463"></p><h3 id="2：类关系图"><a href="#2：类关系图" class="headerlink" title="2：类关系图"></a>2：类关系图</h3><p><img src="image-20180508005928718.png" alt="image-20180508005928718"></p><p> Queue继承Collection,Collection继承Iterable。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *增加一个元素，队列已满，则抛出一个IIIegaISlabEepeplian异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *添加一个元素并返回true，如果队列已满，则返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *移除并返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *移除并返问队列头部的元素，如果队列为空，则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *移除并返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">E <span class="title">element</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  返回队列头部的元素，如果队列为空，则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1：Queue简介&quot;&gt;&lt;a href=&quot;#1：Queue简介&quot; class=&quot;headerlink&quot; title=&quot;1：Queue简介&quot;&gt;&lt;/a&gt;1：Queue简介&lt;/h3&gt;&lt;p&gt;1.1：队列先进先出（First Input First Output），队列是一种
      
    
    </summary>
    
      <category term="数据结构简介" scheme="http://blog.amoswxz.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%80%E4%BB%8B/"/>
    
    
      <category term="数据结构" scheme="http://blog.amoswxz.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构简介（ADT）</title>
    <link href="http://blog.amoswxz.com/2018/04/17/data-structure-introduction/"/>
    <id>http://blog.amoswxz.com/2018/04/17/data-structure-introduction/</id>
    <published>2018-04-16T16:00:00.000Z</published>
    <updated>2018-04-30T14:13:47.368Z</updated>
    
    <content type="html"><![CDATA[<p>一：什么是数据结构：</p><p>数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。</p><p>二：常用的数据结构（大致的介绍，后面会详细介绍）</p><p>1：数组（Array）是包含类似数据类型元素的对象。这是我们存储相似元素的数据结构。我们只能将一组固定的元素存储在java数组中。java中的数组是基于索引的，数组的第一个元素存储在0索引处。查询快；插入删除慢、内存连续、数组大小固定。</p><p>1.1：数组在heap中是分配的内存是连续的。如果查找直接按照索引查询即可。如果想要在2,3中插入4，那么就设计到元素的扩容和元素的移动</p><p><img src="image-20180426005146440.png" alt="image-20180426005146440"></p><p>2：栈（Stack）LIFO 先进后出</p><p>3：队列（Queue）FIFO 先进先出</p><p>4：链表：链表也是线性表的一种，实际有Node节点组成，物理存储结构上不连续，逻辑上连续；大小不固定。查询慢；插入查找快</p><p>4.1：下图展示的是一个单向链表，其中有两个元素，数据域，值域。<br>头指针：我们把指向头节点的指针域成为头指针。头指针是必须存在的。<br>头结点：很多时候，会在链表的头部附加一个结点，该结点的数据域可以不存储任何信息，这个结点称为头结点。<br>头节点值域可以为空，指针域指向下一个节点，最后一个节点的指针域为空。<br>ps：双端链表就是头结点有个引用直接指向最后一个节点。双端链表的好处在于。比如在尾部插入一个结点，双端链表可以进行直接操作但单向链表只能通过next节点循环找到最后结点操作。</p><p><img src="image-20180426105830295.png" alt="image-20180426105830295"></p><p>4.2：下图展示的是一个双向列表</p><p><img src="image-20180426113520797.png" alt="image-20180426113520797"></p><p>5：树（Tree）</p><p>6：图（Graph）</p><p>7：堆（Heap）</p><p>8：散列表（Hash）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一：什么是数据结构：&lt;/p&gt;
&lt;p&gt;数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。&lt;/p&gt;
&lt;p&gt;二：常用的数据结构
      
    
    </summary>
    
      <category term="数据结构简介" scheme="http://blog.amoswxz.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%80%E4%BB%8B/"/>
    
    
      <category term="数据结构" scheme="http://blog.amoswxz.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Hexo快速搭建博客(二)</title>
    <link href="http://blog.amoswxz.com/2018/04/16/hexo1/"/>
    <id>http://blog.amoswxz.com/2018/04/16/hexo1/</id>
    <published>2018-04-15T16:00:00.000Z</published>
    <updated>2018-04-25T06:51:21.855Z</updated>
    
    <content type="html"><![CDATA[<p>一：经常看到别人的博客域名是 <a href="http://amoswxz.github.io/" target="_blank" rel="noopener">username.github.io</a>，这个域名是怎么来的呢？</p><p>1：在github上创建username.github.io的repository的仓库</p><p><img src="hexo1-repository.png" alt="hexo1-repository"></p><p>二：把本地项目上传到创建的username.github.io这个repository。</p><p>1：为hexo安装git插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>2：在项目的根目录_config.yml中配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:amoswxz/AmosWxz.github.io.git</span><br><span class="line">  branch: master</span><br><span class="line">  message: &quot;测试&quot;</span><br></pre></td></tr></table></figure><p>3：执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean(删除生成的public文件夹)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate(生成public文件夹)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行hexo deploy(上传静态文件到github)</span><br></pre></td></tr></table></figure><p>4：网页访问username.github.io的即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一：经常看到别人的博客域名是 &lt;a href=&quot;http://amoswxz.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;username.github.io&lt;/a&gt;，这个域名是怎么来的呢？&lt;/p&gt;
&lt;p&gt;1：在github上创建u
      
    
    </summary>
    
      <category term="Hexo搭建博客" scheme="http://blog.amoswxz.com/categories/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Hexo搭建博客" scheme="http://blog.amoswxz.com/tags/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Hexo快速搭建博客(一)</title>
    <link href="http://blog.amoswxz.com/2018/04/14/hexo/"/>
    <id>http://blog.amoswxz.com/2018/04/14/hexo/</id>
    <published>2018-04-13T16:00:00.000Z</published>
    <updated>2018-04-25T06:51:21.864Z</updated>
    
    <content type="html"><![CDATA[<p>一：hexo是什么？</p><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p>二：安装hexo</p><p>1：安装git,楼主使用的是 <a href="https://brew.sh/" target="_blank" rel="noopener">brew</a> 安装的</p><p>执行：brew install git </p><p><img src="hexo-git.png" alt="hexo-git"></p><p>2：安装node 和 npm</p><p>执行：brew install node</p><p><img src="hexo-registry.png" alt="hexo-registry"></p><p>3：执行 npm install -g hexo-cli ; npm的源在国外,建议修改npm源, 楼主使用的淘宝的源。执行npm config set registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a> 。查看npm使用的源 npm config get registry <img src="hexo-npm-node.png" alt="hexo-npm-node"></p><p>4：hexo init blog 初始化博客项目</p><p>5：执行 npm install  安装依赖</p><p>6：执行 hexo server 启动项目 访问即可</p><p><img src="hexo-end.png" alt="hexo-end"></p><p>7：hexo init blog 使用的是默认主题 landscape,这个主题可能不是那么的beautiful;我们可以更换<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题</a>。楼主使用的是<a href="https://github.com/Ben02/hexo-theme-Anatole/" target="_blank" rel="noopener">anatole</a>主题。如果想要更换主题直接clone主题到项目的themes文件夹。更改项目根目录_config.yml中theme的值即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一：hexo是什么？&lt;/p&gt;
&lt;p&gt;Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 &lt;a href=&quot;http://daringfireball.net/projects/markdown/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Mar
      
    
    </summary>
    
      <category term="Hexo搭建博客" scheme="http://blog.amoswxz.com/categories/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Hexo搭建博客" scheme="http://blog.amoswxz.com/tags/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
