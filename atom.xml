<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Amos</title>
  
  <subtitle>Amos</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.amoswxz.com/"/>
  <updated>2018-04-25T06:51:21.867Z</updated>
  <id>http://blog.amoswxz.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>集合源码篇（LinkedList）</title>
    <link href="http://blog.amoswxz.com/2018/04/25/LinkedList/"/>
    <id>http://blog.amoswxz.com/2018/04/25/LinkedList/</id>
    <published>2018-04-24T16:00:00.000Z</published>
    <updated>2018-04-25T06:51:21.867Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="集合源码" scheme="http://blog.amoswxz.com/categories/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="集合源码" scheme="http://blog.amoswxz.com/tags/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>集合源码篇（ArrayList）</title>
    <link href="http://blog.amoswxz.com/2018/04/18/ArrayList/"/>
    <id>http://blog.amoswxz.com/2018/04/18/ArrayList/</id>
    <published>2018-04-17T16:00:00.000Z</published>
    <updated>2018-04-25T06:52:20.167Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ArrayList简介"><a href="#ArrayList简介" class="headerlink" title="ArrayList简介"></a>ArrayList简介</h3><p>ArrayList是基于数组实现的，是一个动态数组。容量可以自动增加动态增长内存。</p><p>ArrayList是线程不安全的，只能在单线程环境下使用。多线程环境下使用juc下面的CopyOnWriteArrayList（后续会介绍）</p><h3 id="ArrayList类关系继承图"><a href="#ArrayList类关系继承图" class="headerlink" title="ArrayList类关系继承图"></a>ArrayList类关系继承图</h3><p><img src="ArrayList.png" alt="ArrayList"></p><p>从该图可以看到，ArrayList继承AbstractList类，AbstractList类实现List接口；ArrayList实现了List接口。有人就会问，为什么ArrayList既要继承AbstractList又实现了List接口呢。这是因为java集合框架用到了很多适配器模式，用AbstractList去实现List接口，这样ArrayList继承AbstractList只需要重写自己需要的方法即可，不用实现接口中的所有方法。实现了randomAccess接口，RandomAccess 是一个空的接口，它用来标识某个类是否支持 <strong>随机访问</strong>（随机访问，相对比“按顺序访问”）。一个支持随机访问的类明显可以使用更加高效的算法。</p><h5 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">import</span> java.util.function.UnaryOperator;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**很多人往往忽略了类上面的注释，其实这个注释才是最重要的。上面注释大概介绍了几点</span></span><br><span class="line"><span class="comment">         *1：ArrayList是List接口的大小可变数组实现的，实现了List中接口中的所有方法。允许元素为null。</span></span><br><span class="line"><span class="comment">         *2：时间复杂度：size()，isEmpty()，get()，set()，iterator()，listIterator()，这些操作时间复杂度是 o(1)。</span></span><br><span class="line"><span class="comment">         因为是根据数组下标实现的。可以根据索引直接定位到元素位置。add()，remove()方法的时间复杂度是o(n)。因为添加删除元素需要移动元素位置。</span></span><br><span class="line"><span class="comment">         *3：ArrayList容量可以自动增长</span></span><br><span class="line"><span class="comment">         *4：ArrayList不是同步的，并发修改会返回fail-fast。会抛出ConcurrentModificationException**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Default initial capacity.</span></span><br><span class="line"><span class="comment">     * 默认初始化容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定ArrayList容量为0时，返回该空数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用无参构造的时候返回该对象。与EMPTY_ELEMENTDATA的区别在于</span></span><br><span class="line"><span class="comment">     * 指定容量大小为0返回EMPTY_ELEMENTDATA。默认返回DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存到ArrayList中元素，ArrayList的容量就是数组大小</span></span><br><span class="line"><span class="comment"> * 第一次添加元素到ArrayList，该数组扩容为默认的大小DEFAULT_CAPACITY</span></span><br><span class="line"><span class="comment">     * transient 被标记表示不可序列化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The size of the ArrayList (the number of elements it contains).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     * ArrayList的大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ArrayList提供了三个构造函数"><a href="#ArrayList提供了三个构造函数" class="headerlink" title="ArrayList提供了三个构造函数"></a>ArrayList提供了三个构造函数</h5><p><img src="image-201804190003174.png" alt="image-201804190003174"></p><p>初始化一个空数组：注意这里并不是初始化容量为10的数组</p><p>初始化一个collection 元素列表。将collection转为数组，判断数组大小是否为0，如果是0返回EMPTY_ELEMENTDATA。否则返回的是重新创建的数组并且数组大小是传入的collection大小.</p><p><img src="image-201804190007478.png" alt="image-201804190007478"></p><p>注意事项：</p><p><a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6260652" target="_blank" rel="noopener">c.toArray might (incorrectly) not return Object[] (see 6260652) 这里其实是一个JDK1.8的bug</a> ；这个bug的意思就是 Arrays.asList(x).toArray().getClass() should be Object[].class 但是返回的是class [Ljava.lang.String；jdk9已经修复。</p><p>Arrays.copy方法调用的是</p><p><img src="image-201804192120011.png" alt="image-201804192120011"></p><p><a href="https://stackoverflow.com/questions/29494800/do-not-understand-the-source-code-of-arrays-copyof" target="_blank" rel="noopener">这里为什么要判断((Object)newType == (Object)Object[].class)  如果是Object直接静态创建，在Array.newInstance中创建新实例的原因很可能是性能选择，如果程序总是需要创建新实例，那么它将比直接初始化一个通用对象数组和复制东西更加昂贵。Stack Overflow 上面有对该代码的解释</a></p><p>ArrayList中方法介绍</p><p>trimToSize()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 优化数组大小，只保留存储添加进去元素的空间</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     modCount++;</span><br><span class="line">     <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">         elementData = (size == <span class="number">0</span>)</span><br><span class="line">           ? EMPTY_ELEMENTDATA</span><br><span class="line">           : Arrays.copyOf(elementData, size);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>add()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//当前size+1</span></span><br><span class="line">      ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">      elementData[size++] = e;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断当前元素是否等于空 第一次执行add的时候执行才会是true</span></span><br><span class="line">      <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">          <span class="comment">//当前容量和默认容量10比较，取大的值</span></span><br><span class="line">          minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">      &#125;</span><br><span class="line">      ensureExplicitCapacity(minCapacity);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//结构修改次数；该变量主要是用来实现fail-fast机制的    </span></span><br><span class="line">      modCount++;</span><br><span class="line">      <span class="comment">// overflow-conscious code</span></span><br><span class="line">      <span class="comment">//当前size+1大于数组容量进行扩容</span></span><br><span class="line">      <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">          grow(minCapacity);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 增加容量以确保它至少能容纳。</span></span><br><span class="line"><span class="comment">* 最小容量参数指定的元素个数。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// overflow-conscious code</span></span><br><span class="line">      <span class="comment">// 获取老的数组大小</span></span><br><span class="line">      <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">      <span class="comment">//新的数组大小=1.5倍老的数组大小</span></span><br><span class="line">      <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 第一次扩容的时候才会用到，即第一次add的时候</span></span><br><span class="line">      <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">          newCapacity = minCapacity;</span><br><span class="line">      <span class="comment">/**为什么要减去8呢？</span></span><br><span class="line"><span class="comment">       *因为某些JVM会在数组中保留一些头字，尝试分配这个最大存储容量，可能会导致array容量大于JVM的限制，最终导致OutOfMemoryError。</span></span><br><span class="line"><span class="comment">       *判断数组容量是否达到Integer.MAX_VALUE - 8,达到就返回Integer.MAX_VALUE - 8**/</span></span><br><span class="line">      <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">          newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">      <span class="comment">//数组扩容</span></span><br><span class="line">      elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">      <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">          Integer.MAX_VALUE :</span><br><span class="line">          MAX_ARRAY_SIZE;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>iterator()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">      <span class="comment">//访问下一个元素的索引</span></span><br><span class="line">      <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">      <span class="comment">//访问上一个元素的索引</span></span><br><span class="line">      <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">      <span class="comment">//ArrayList修改次数</span></span><br><span class="line">      <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//判断是否有下一个元素</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> cursor != size;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//获取下一个元素</span></span><br><span class="line">      <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">      <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">//检查集合内容是否被修改</span></span><br><span class="line">          checkForComodification();</span><br><span class="line">          <span class="keyword">int</span> i = cursor;</span><br><span class="line">          <span class="comment">//下一个元素的下标等于size说明没有元素</span></span><br><span class="line">          <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">          <span class="comment">//获取ArrayList中数据</span></span><br><span class="line">          Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">          <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">          cursor = i + <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">          checkForComodification();</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">//删除元素</span></span><br><span class="line">              ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">              <span class="comment">//删除元素的下标给下一个元素</span></span><br><span class="line">              cursor = lastRet;</span><br><span class="line">              lastRet = -<span class="number">1</span>;</span><br><span class="line">              expectedModCount = modCount;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; consumer)</span> </span>&#123;</span><br><span class="line">          Objects.requireNonNull(consumer);</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">int</span> size = ArrayList.<span class="keyword">this</span>.size;</span><br><span class="line">          <span class="keyword">int</span> i = cursor;</span><br><span class="line">          <span class="keyword">if</span> (i &gt;= size) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">final</span> Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">          <span class="keyword">if</span> (i &gt;= elementData.length) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="line">              consumer.accept((E) elementData[i++]);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// update once at end of iteration to reduce heap write traffic</span></span><br><span class="line">          cursor = i;</span><br><span class="line">          lastRet = i - <span class="number">1</span>;</span><br><span class="line">          checkForComodification();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>   Amos在面试阿里的时候，阿里的一个面试官当初就问了Amos关于二个问题。</p><p>一：并发修改List会报什么错。当时一脸懵逼，只知道会报错，但是不知道报什么错==ConcurrentModificationException。==</p><p>二：遍历list的时候怎么样才能正确的删除数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误的写法，这里调用str.remove改变了modCount的值，所以报错ConcurrentModificationException</span></span><br><span class="line">    ArrayList&lt;Integer&gt; str = Lists.newArrayList();</span><br><span class="line">            str.add(<span class="number">1</span>);</span><br><span class="line">            str.add(<span class="number">2</span>);</span><br><span class="line">            str.add(<span class="number">3</span>);</span><br><span class="line">            <span class="comment">//此时iterator中的expactModCount=3</span></span><br><span class="line">            Iterator&lt;Integer&gt; iterator = str.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                Integer next = iterator.next();</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">//调用remove以后modCount=3+1 所以下一次调用iterator.next的时候报错</span></span><br><span class="line">                    str.remove(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//错误的写法 foreach循环底层用的还是iterator</span></span><br><span class="line"> ArrayList&lt;Integer&gt; str = Lists.newArrayList();</span><br><span class="line">        str.add(<span class="number">1</span>);</span><br><span class="line">        str.add(<span class="number">2</span>);</span><br><span class="line">        str.add(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer s : str) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="number">1</span>) &#123;</span><br><span class="line">                str.remove(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确写法一</span></span><br><span class="line">    ArrayList&lt;Integer&gt; str = Lists.newArrayList();</span><br><span class="line">            str.add(<span class="number">1</span>);</span><br><span class="line">            str.add(<span class="number">2</span>);</span><br><span class="line">            str.add(<span class="number">3</span>);</span><br><span class="line">            <span class="comment">//此时iterator中的expactModCount=3</span></span><br><span class="line">            Iterator&lt;Integer&gt; iterator = str.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                Integer next = iterator.next();</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="comment">//调用remove以后modCount=3+1 所以下一次调用iterator.next的时候报错</span></span><br><span class="line">          <span class="comment">//这里使用iterator调用 这里改变了cursor下标，改变了expectModCount的值，所以不出现ConcurrentModificationException</span></span><br><span class="line">                   iterator.remove(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//也可以使用for循环删除。删除某个元素后，list的大小发生了变化，而你的索引也在变化，所以会导致你在遍历的时候漏掉某些元素</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ArrayList简介&quot;&gt;&lt;a href=&quot;#ArrayList简介&quot; class=&quot;headerlink&quot; title=&quot;ArrayList简介&quot;&gt;&lt;/a&gt;ArrayList简介&lt;/h3&gt;&lt;p&gt;ArrayList是基于数组实现的，是一个动态数组。容量可以自动增加
      
    
    </summary>
    
      <category term="集合源码" scheme="http://blog.amoswxz.com/categories/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="集合源码" scheme="http://blog.amoswxz.com/tags/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>数据结构简介（ADT）</title>
    <link href="http://blog.amoswxz.com/2018/04/17/data-structure-introduction/"/>
    <id>http://blog.amoswxz.com/2018/04/17/data-structure-introduction/</id>
    <published>2018-04-16T16:00:00.000Z</published>
    <updated>2018-04-26T03:47:43.991Z</updated>
    
    <content type="html"><![CDATA[<p>一：什么是数据结构：</p><p>数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。</p><p>二：常用的数据结构（大致的介绍，后面会详细介绍）</p><p>1：数组（Array）是包含类似数据类型元素的对象。这是我们存储相似元素的数据结构。我们只能将一组固定的元素存储在java数组中。java中的数组是基于索引的，数组的第一个元素存储在0索引处。查询快；插入删除慢、内存连续、数组大小固定。</p><p>1.1：数组在heap中是分配的内存是连续的。如果查找直接按照索引查询即可。如果想要在2,3中插入4，那么就设计到元素的扩容和元素的移动</p><p><img src="image-20180426005146440.png" alt="image-20180426005146440"></p><p>2：栈（Stack）LIFO 先进后出</p><p>3：队列（Queue）FIFO 先进先出</p><p>4：链表：链表也是线性表的一种，实际有Node节点组成，在内存中可以不是连续的。查询慢；插入查找快</p><p>4.1：下图展示的是一个单向链表，头节点值域为空，指针域指向下一个节点，最后一个节点的指针域为空。</p><p>​    ps：双端链表就是头结点有个引用直接指向最后一个节点。双端链表的好处在于。比如在尾部插入一个结点，双端链表可以进行直接操作但单向链表只能通过next节点循环找到最后结点操作。</p><p><img src="image-20180426105830295.png" alt="image-20180426105830295"></p><p>4.2：下图展示的是一个双向列表</p><p><img src="image-20180426113520797.png" alt="image-20180426113520797"></p><p>5：树（Tree）</p><p>6：图（Graph）</p><p>7：堆（Heap）</p><p>8：散列表（Hash）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一：什么是数据结构：&lt;/p&gt;
&lt;p&gt;数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。&lt;/p&gt;
&lt;p&gt;二：常用的数据结构
      
    
    </summary>
    
      <category term="数据结构简介" scheme="http://blog.amoswxz.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%80%E4%BB%8B/"/>
    
    
      <category term="数据结构" scheme="http://blog.amoswxz.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Hexo快速搭建博客(二)</title>
    <link href="http://blog.amoswxz.com/2018/04/16/hexo1/"/>
    <id>http://blog.amoswxz.com/2018/04/16/hexo1/</id>
    <published>2018-04-15T16:00:00.000Z</published>
    <updated>2018-04-25T06:51:21.855Z</updated>
    
    <content type="html"><![CDATA[<p>一：经常看到别人的博客域名是 <a href="http://amoswxz.github.io/" target="_blank" rel="noopener">username.github.io</a>，这个域名是怎么来的呢？</p><p>1：在github上创建username.github.io的repository的仓库</p><p><img src="hexo1-repository.png" alt="hexo1-repository"></p><p>二：把本地项目上传到创建的username.github.io这个repository。</p><p>1：为hexo安装git插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>2：在项目的根目录_config.yml中配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:amoswxz/AmosWxz.github.io.git</span><br><span class="line">  branch: master</span><br><span class="line">  message: &quot;测试&quot;</span><br></pre></td></tr></table></figure><p>3：执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean(删除生成的public文件夹)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate(生成public文件夹)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行hexo deploy(上传静态文件到github)</span><br></pre></td></tr></table></figure><p>4：网页访问username.github.io的即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一：经常看到别人的博客域名是 &lt;a href=&quot;http://amoswxz.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;username.github.io&lt;/a&gt;，这个域名是怎么来的呢？&lt;/p&gt;
&lt;p&gt;1：在github上创建u
      
    
    </summary>
    
      <category term="Hexo搭建博客" scheme="http://blog.amoswxz.com/categories/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Hexo搭建博客" scheme="http://blog.amoswxz.com/tags/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Hexo快速搭建博客(一)</title>
    <link href="http://blog.amoswxz.com/2018/04/14/hexo/"/>
    <id>http://blog.amoswxz.com/2018/04/14/hexo/</id>
    <published>2018-04-13T16:00:00.000Z</published>
    <updated>2018-04-25T06:51:21.864Z</updated>
    
    <content type="html"><![CDATA[<p>一：hexo是什么？</p><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p>二：安装hexo</p><p>1：安装git,楼主使用的是 <a href="https://brew.sh/" target="_blank" rel="noopener">brew</a> 安装的</p><p>执行：brew install git </p><p><img src="hexo-git.png" alt="hexo-git"></p><p>2：安装node 和 npm</p><p>执行：brew install node</p><p><img src="hexo-registry.png" alt="hexo-registry"></p><p>3：执行 npm install -g hexo-cli ; npm的源在国外,建议修改npm源, 楼主使用的淘宝的源。执行npm config set registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a> 。查看npm使用的源 npm config get registry <img src="hexo-npm-node.png" alt="hexo-npm-node"></p><p>4：hexo init blog 初始化博客项目</p><p>5：执行 npm install  安装依赖</p><p>6：执行 hexo server 启动项目 访问即可</p><p><img src="hexo-end.png" alt="hexo-end"></p><p>7：hexo init blog 使用的是默认主题 landscape,这个主题可能不是那么的beautiful;我们可以更换<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题</a>。楼主使用的是<a href="https://github.com/Ben02/hexo-theme-Anatole/" target="_blank" rel="noopener">anatole</a>主题。如果想要更换主题直接clone主题到项目的themes文件夹。更改项目根目录_config.yml中theme的值即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一：hexo是什么？&lt;/p&gt;
&lt;p&gt;Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 &lt;a href=&quot;http://daringfireball.net/projects/markdown/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Mar
      
    
    </summary>
    
      <category term="Hexo搭建博客" scheme="http://blog.amoswxz.com/categories/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Hexo搭建博客" scheme="http://blog.amoswxz.com/tags/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
